process.on("uncaughtException", console.error);
process.on("unhandledRejection", console.error);
import makeWASocket, {
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  makeCacheableSignalKeyStore,
  DisconnectReason,
  generateForwardMessageContent,
  generateWAMessageFromContent
} from "@whiskeysockets/baileys";
import { Boom } from "@hapi/boom";
import readline from "readline";
import { translate } from '@vitalets/google-translate-api';
import { cmdToIGif } from "./commands/toigif.js";
import { cmdToImg } from "./commands/toimg.js";
import chalk from "chalk";
import pino from "pino";
import { isBanned } from "./utils/ban.js";
import { mafiaCommand, mafiaDB } from "./games/mafia.js";



import { cmdPublicarGacha, cmdGacha, cmdGclaim } from "./gachaCommands.js";


import { exec } from "child_process";
import OpenAI from "openai";

import cmdTranslate from './commands/translate.js';
import { cmdToIVideo } from "./commands/toivideo.js";

// Crear instancia con tu API Key
const channelInfo = {
    isForwarded: true,
    forwardingScore: 2,
    forwardedNewsletterMessageInfo: {
        newsletterJid: "120363422781423966@newsletter",
        newsletterName: "üåπCrizZappüåπ",
        serverMessageId: 1
    }
};
//pwpepdkd9d
const openai = new OpenAI({
  apiKey: "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"
});
import { menuText, menuImage } from "./menu.js";
import { cmdPerfil } from './commands/perfil.js';
import * as economia from './utils/economy.js';
import cmdTts from "./commands/tts.js";
import fetch from "node-fetch";
import fs from "fs";
import path from "path";
import { cmdTienda, cmdComprar, cmdApoyar } from "./utils/shop.js";
import { cmdSetBio } from "./commands/setbio.js";
import axios from 'axios';
import { load } from 'cheerio';
const owner = "74694329925676@lid";
import figlet from "figlet";
import {
  personajes,
  cmdRW,
  cmdClaim,
  cmdColeccion,
  cmdBoost,
  cmdGift,
  cmdVender,
  cmdVerTiendarw,
  cmdComprarrw
} from "./commands/rw.js";
import { messageStore } from "./messageStore.js";
import { loadUsers, saveUsers, initializeUser } from './utils/users.js';
import { cmdMeme } from "./commands/meme.js";
import { mascota, adoptar, alimentar, jugar, dormir, verMascota } from './mascota.js';

// Lee tu propio index.js
const indexFile = fs.readFileSync("./index.js", "utf-8");

// Extrae todos los comandos
const comandos = [...indexFile.matchAll(/case\s+"(.+?)"/g)].map(m => m[1]);
// Al inicio de tu index.js
import ytSearch from 'yt-search';
import ytdl from 'ytdl-core';
const OWNER = "74694329925676@lid";
import { nsfwHandler } from "./commands/nsfw.js";
import { antiDelete } from "./antidelete.js";

// Funci√≥n universal para descargar media SIN usar sock.*
global.nsfwGroups = global.nsfwGroups || {};

if (fs.existsSync("./nsfw.json")) {
    global.nsfwGroups = JSON.parse(fs.readFileSync("./nsfw.json"));
}

function saveNSFW() {
    fs.writeFileSync("./nsfw.json", JSON.stringify(global.nsfwGroups, null, 2));
}

// ‚¨ÜÔ∏è ARRIBA DEL TODO, antes del sock.ev.on

function saludoPorHora() {
    const hora = new Date().getHours();

    if (hora >= 0 && hora < 6) {
        return "üåÉ Mejor Duerme, es tarde";
    } else if (hora >= 6 && hora < 12) {
        return "üåÖ Buenos d√≠as";
    } else if (hora >= 12 && hora < 18) {
        return "‚òÄÔ∏è Buenas tardes";
    } else {
        return "üåô Buenas noches";
    }
}

//ps√±d
async function descargarMedia(msg) {
    const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;

    const media =
        msg.message?.imageMessage ||
        msg.message?.videoMessage ||
        quoted?.imageMessage ||
        quoted?.videoMessage;

    if (!media) return null;

    const type = media.mimetype.startsWith("video") ? "video" : "image";
    const stream = await downloadContentFromMessage(media, type);

    let buffer = Buffer.from([]);
    for await (const chunk of stream) {
        buffer = Buffer.concat([buffer, chunk]);
    }

    return buffer;
}
//pepe
import { downloadContentFromMessage } from "@whiskeysockets/baileys";

async function getFileBufferBaileys(message) {
    const type = Object.keys(message)[0]; 
    const stream = await downloadContentFromMessage(
        message[type],
        type.replace("Message", "")
    );
    let buffer = Buffer.from([]);
    for await (const chunk of stream) {
        buffer = Buffer.concat([buffer, chunk]);
    }
    return buffer;
}
//XD
// Usuarios muteados por grupo
const mutedUsers = new Set();
// key: groupJid
// value: Set de usuarios muteados
//j
async function getBuffer(url) {
    const res = await axios.get(url, { responseType: "arraybuffer" });
    return Buffer.from(res.data);
}
// Objeto para guardar estado del antilink 
async function resumirTexto(texto) {
  const response = await openai.chat.completions.create({
    model: "gpt-4o-mini", // puedes usar gpt-4o-mini o gpt-4o
    messages: [
      { role: "system", content: "Eres un asistente que resume textos." },
      { role: "user", content: texto }
    ],
    max_tokens: 200
  });

  return response.choices[0].message.content;
}
//por grupo
let welcomeStatus = {}; // { "id_grupo": true/false }
let antilinkStatus = {}; // ejemplo: { "120363403524067469@g.us": true }
let giftActive = false;
let giftedCharacter = null;

let byeStatus = {};

let giftEndsAt = null;
// Objeto para guardar el estado de los juegos por usuario o chat
let juegos = {}; // <--- esto es clave
// Luego en tu manejador de comandos:

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const question = (text) => new Promise((resolve) => rl.question(text, resolve));
const gruposBaneados = new Set();
const nombresUsuarios = {};  // <-- Declaraci√≥n global UNA sola vez

export async function cmdPing(sock, from) {
  const start = Date.now();

  const sentMsg = await sock.sendMessage(from, {
    text: "‚è±Ô∏è Calculando ping...",
  });

  const ping = Date.now() - start;

  await sock.sendMessage(from, {
    text: `üèì *Ping:* ${ping}ms\n‚ö° Latencia estable.`,
    edit: sentMsg.key,
  });
}
// ======================
// ESTADO PERSISTENTE
try {
    const data = fs.readFileSync('./status.json', 'utf-8');
    const parsed = JSON.parse(data);
    welcomeStatus = parsed.welcomeStatus || {};
    byeStatus = parsed.byeStatus || {};
    antilinkStatus = parsed.antilinkStatus || {};
} catch {
    console.log("No se encontr√≥ status.json, se crear√° uno nuevo.");
}

function saveStatus() {
    fs.writeFileSync(
        './status.json',
        JSON.stringify({ welcomeStatus, byeStatus, antilinkStatus }, null, 2)
    );
}

async function startBot() {
  console.clear();
  figlet('Cris Bot Base', (err, data) => {
  if (err) {
    console.log('Error creando arte ASCII');
    console.error(err);
    return;
  }
  console.log(data); // Esto imprime las letras grandes en consola

  console.log("üî• Iniciando Cris-Base"); // Tu mensaje normal
});

  const { state, saveCreds } = await useMultiFileAuthState("./session");
  const { version } = await fetchLatestBaileysVersion();

  const sock = makeWASocket({
    version,
    logger: pino({ level: "silent" }),
    printQRInTerminal: false,
    browser: ["Ubuntu", "Chrome", "20.0.0"],
    auth: {
      creds: state.creds,
      keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })),
    },
    markOnlineOnConnect: true,
    generateHighQualityLinkPreview: true,
    syncFullHistory: false,
  });
//pepe
sock.ev.on("group-participants.update", async (update) => {
    const { id, participants, action } = update;


if (!byeStatus[id]) return;
if (action !== "remove") return;

for (let user of participants) {

    const jid = typeof user === "string" ? user : user.id;
    const nombre = jid.split("@")[0];

    // ----- FOTO DE PERFIL -----
    let perfil;
    try {
        const url = await sock.profilePictureUrl(jid, "image");
        if (url) {
            const res = await axios.get(url, { responseType: "arraybuffer" });
            perfil = Buffer.from(res.data);
        }
    } catch {
        perfil = null;
    }

    // Imagen backup si no tiene foto
    if (!perfil) {
        const res = await axios.get("https://i.imgur.com/7Y4kF3k.jpeg", { responseType: "arraybuffer" });
        perfil = Buffer.from(res.data);
    }

    // ----- MENSAJE DE DESPEDIDA -----
    const mensaje =
`‚ï≠‚îÄ‚îÄ *üëã ADI√ìS* ‚îÄ‚îÄ‚ïÆ
‚îÇ üë§ Usuario: @${nombre}
‚îÇ üò¢ Ha salido del grupo
‚îÇ üçÄ ¬°Suerte en tu camino!
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`;

    await sock.sendMessage(id, {
        image: perfil,
        caption: mensaje,
        mentions: [jid]
    });
}

    if (!welcomeStatus[id]) return;
    if (action !== "add") return;

    for (let user of participants) {

        // Fix para Baileys (objeto o string)
        const jid = typeof user === "string" ? user : user.id;
        const nombre = jid.split("@")[0];

        // ----- FOTO DE PERFIL -----
        let perfil;
        try {
            const url = await sock.profilePictureUrl(jid, "image");
            if (url) {
                const res = await axios.get(url, { responseType: "arraybuffer" });
                perfil = Buffer.from(res.data);
            }
        } catch {
            perfil = null;
        }

        // Imagen backup si no tiene foto
        if (!perfil) {
            const res = await axios.get("https://i.imgur.com/7Y4kF3k.jpeg", { responseType: "arraybuffer" });
            perfil = Buffer.from(res.data);
        }

        // ----- MENSAJE BONITO -----
        const mensaje = 
`‚ï≠‚îÄ‚îÄ *üåü BIENVENIDO üåü* ‚îÄ‚îÄ‚ïÆ
‚îÇ üë§ Usuario: @${nombre}
‚îÇ üéâ ¬°Disfruta del grupo!
‚îÇ üìå Lee las reglas para evitar sanciones.
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`;

        await sock.sendMessage(id, {
            image: perfil,
            caption: mensaje,
            mentions: [jid]
        });
    }
});

  // Spam delay
function getMentionedJid(msg) {
    return (
        msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] ||
        null
    );
}
  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  if (!sock.authState.creds.registered) {
    let number = await question(chalk.cyan("üì± Escribe tu n√∫mero de WhatsApp con c√≥digo de pa√≠s (solo n√∫meros): "));
    number = number.replace(/[^0-9]/g, "");
    if (!number) {
      console.log(chalk.red("‚ùå N√∫mero inv√°lido."));
      process.exit(1);
    }

    console.log(chalk.yellow("‚åõ Solicitando c√≥digo de vinculaci√≥n..."));
    try {
      const code = await sock.requestPairingCode(number);
      console.log(chalk.bgGreen.black("‚úÖ C√ìDIGO DE VINCULACI√ìN:"), chalk.white(code));
      console.log(chalk.gray("Comparte este c√≥digo para conectar tu subbot."));
    } catch (err) {
      console.error(chalk.red("‚ùå Error al generar c√≥digo de vinculaci√≥n:"), err.message);
      process.exit(1);
    }
  }

  sock.ev.on("connection.update", (update) => {
    const { connection, lastDisconnect } = update;
    if (connection === "close") {
      const reason = new Boom(lastDisconnect?.error)?.output?.statusCode;
      if (reason === DisconnectReason.loggedOut) {
        console.log(chalk.red("‚ùå Sesi√≥n cerrada, elimina ./session para reemparejar"));
        process.exit(0);
      } else {
        console.log(chalk.yellow("‚ö†Ô∏è Conexi√≥n cerrada, intentando reconectar..."));
        startBot();
      }
    } else if (connection === "open") {
      console.log(chalk.greenBright("‚úÖ Conectado sin QR"));
      exec("rm -rf tmp && mkdir tmp");
    }
  });

  const OWNER_JID = "74694329925676@lid";  // Define aqu√≠ tu JID owner

  sock.ev.on("creds.update", saveCreds);

  sock.ev.on("messages.upsert", async (m) => {
    try {
      const msg = m.messages[0];
      if (!msg.message) return;
      if (msg.key && msg.key.remoteJid === "status@broadcast") return;

      const from = msg.key.remoteJid;
      const isGroup = from.endsWith("@g.us");
      const sender = isGroup ? msg.key.participant : from;

//nekd
// üîá BLOQUEAR MENSAJES DE USUARIOS MUTEADOS
if (isGroup && mutedUsers.has(sender)) {
    await sock.sendMessage(from, {
        delete: {
            remoteJid: from,
            fromMe: false,
            id: msg.key.id,
            participant: sender
        }
    });
    return;
}

      // Ignorar mensajes si el grupo est√° baneado
      if (isGroup && gruposBaneados.has(from)) {
        return;
      }

      const type = Object.keys(msg.message)[0];
      const text =
        type === "conversation"
          ? msg.message.conversation
          : type === "extendedTextMessage"
          ? msg.message.extendedTextMessage.text
          : "";
// Detectar nuevos miembros cuando welcome est√° activo
if (m.type === "notify" && m.messages[0]?.messageStubType === 27) {
    const grupo = msg.key.remoteJid;

    if (welcomeStatus[grupo]) {
        const nuevos = msg.messageStubParameters; 

        for (let user of nuevos) {
            await sock.sendMessage(grupo, {
                text: `üëã *Bienvenido @${user.split("@")[0]}*  
‚ú® Disfruta del grupo.`,
                mentions: [user]
            });
        }
    }
}


    // üß† GUARDAR MENSAJES (antes de procesar comandos)
    if (msg.key && msg.message && !msg.message.protocolMessage) {
        messageStore[msg.key.id] = {
            message: msg.message,
            sender: msg.key.participant || msg.key.remoteJid,
            from
        };
    }

    // üö® MENSAJE BORRADO
    if (msg.message?.protocolMessage?.type === 0) {
        const deletedKey = msg.message.protocolMessage.key;
        const deletedMsg = messageStore[deletedKey.id];

        if (!deletedMsg) return;
        if (!isGroup || !antiDelete[from]) return;

        const user = deletedMsg.sender;

        await sock.sendMessage(from, {
            text: `üõë *Mensaje eliminado*\nüë§ @${user.split("@")[0]}`,
            mentions: [user]
        });

        await sock.relayMessage(
    from,
    deletedMsg.message,
    { messageId: deletedKey.id }
);
        return;
    }

if (msg.key?.remoteJid?.endsWith('@newsletter')) {
  global.ultimoMensajeCanal = msg
}

if (isGroup && antilinkStatus[from]) {
    let msgText = '';

    if (msg.message.conversation) msgText = msg.message.conversation;
    else if (msg.message.extendedTextMessage) msgText = msg.message.extendedTextMessage.text;
    else if (msg.message.imageMessage && msg.message.imageMessage.caption) msgText = msg.message.imageMessage.caption;
    else if (msg.message.videoMessage && msg.message.videoMessage.caption) msgText = msg.message.videoMessage.caption;

    const linkRegex = /(https?:\/\/\S+|chat\.whatsapp\.com\/\S+|wa\.me\/\S+)/gi;

    if (linkRegex.test(msgText)) {
        const groupMeta = await sock.groupMetadata(from);
        const adminIds = groupMeta.participants.filter(p => p.admin !== null).map(p => p.id);

        if (!adminIds.includes(sender)) {
            try {
                // üîπ BORRAR MENSAJE
                await sock.sendMessage(from, {
                    delete: {
                        remoteJid: from,
                        id: msg.key.id,
                        participant: msg.key.participant
                    }
                });

                // üîπ EXPULSAR USUARIO
                await sock.groupParticipantsUpdate(from, [sender], "remove");

                await sock.sendMessage(from, { 
                    text: `‚ùå  fue expulsado por enviar un link.` 
                });
            } catch (err) {
                console.error(err);
                await sock.sendMessage(from, { text: "‚ùå No se pudo expulsar al usuario o borrar el mensaje. ¬øSoy admin?" });
            }
        }
    }
}
      const now = new Date();
      const hora = now.toLocaleTimeString("es-ES", { hour12: false });
      const data = now.toLocaleDateString("es-ES");

      const pushName = msg.pushName || "Desconocido";

      // Log mensajes
      if (text) {
        if (!isGroup) {
          if (text.startsWith("#")) {
            console.log(
              `\n‚ïî‚ïê‚îÅ‚îÅ‚îÅ‚îÅ ${chalk.blue("CMD „Äå USUARIO „Äç")} ‚îÅ‚îÅ‚îÅ‚îÅ‚ïó\n` +
                `${chalk.green("NOMBRE :")} ${chalk.cyan(pushName)}\n` +
                `${chalk.green("MENSAJE :")} ${chalk.cyan(text)}\n` +
                `${chalk.green("HORA   :")} ${chalk.cyan(hora)}\n` +
                `${chalk.green("FECHA  :")} ${chalk.cyan(data)}\n` +
                "‚ïö‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïù"
            );
          } else {
            console.log(
              `\n‚ïî‚ïê‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ${chalk.blue("CHAT „Äå BOT „Äç")} ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïó\n` +
                `${chalk.green("NOMBRE :")} ${chalk.cyan(pushName)}\n` +
                `${chalk.green("MENSAJE :")} ${chalk.cyan(text)}\n` +
                `${chalk.green("HORA   :")} ${chalk.cyan(hora)}\n` +
                `${chalk.green("FECHA  :")} ${chalk.cyan(data)}\n` +
                "‚ïö‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïù"
            );
          }
        } else {
          console.log(
            `\n‚ïî‚ïê‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ${chalk.blue("GRUPO „Äå BOT „Äç")} ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïó\n` +
              `${chalk.green("GRUPO  :")} ${chalk.cyan(from)}\n` +
              `${chalk.green("NOMBRE :")} ${chalk.cyan(pushName)}\n` +
              `${chalk.green("MENSAJE:")} ${chalk.cyan(text)}\n` +
              `${chalk.green("HORA   :")} ${chalk.cyan(hora)}\n` +
              `${chalk.green("FECHA  :")} ${chalk.cyan(data)}\n` +
              "‚ïö‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïù"
          );
        }
      }

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMANDOS SIN PREFIJO (RISAS) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const texto = text.toLowerCase().trim()

const esXd = /^(Xd)+$/.test(texto)
const esXd = /^(X)+$/.test(texto)
// Detectar JA / JAJA / JAJAJA...
const esRisaJa = /^(ja)+$/.test(texto)

if (esXd) {
  try {
    const img = fs.readFileSync("./pena.jpg") // ‚Üê TU IMAGEN

    await sock.sendMessage(from, {
      image: img,
      caption: "Tenias tanto que dar y decidiste dar pena üòî"
    }, { quoted: msg })

  } catch (e) {
    console.error("Error enviando imagen:", e)
  }

// Detectar XD / X'D / XD XD


if (esRisaJa) {
  try {
    const img = fs.readFileSync("./circo.jpg") // ‚Üê TU IMAGEN

    await sock.sendMessage(from, {
      image: img,
      caption: "üé™ *El circo queda para all√°* üëâü§°"
    }, { quoted: msg })

  } catch (e) {
    console.error("Error enviando imagen:", e)
  }

  return // ‚õî IMPORTANTE: corta aqu√≠ para que no siga
}

      const prefixes = ['#', '.', '!', '/', '$']

if (!prefixes.some(p => text.startsWith(p))) return

      const args = text.slice(1).trim().split(/ +/);
      const command = args.shift().toLowerCase();

      // Aqu√≠ NO redeclarar nombresUsuarios, solo usar la global
      if (pushName && sender) {
        nombresUsuarios[sender] = pushName;
      }

      switch (command) {
        case "hi":
          await sock.sendMessage(from, { text: "Hola amigo üëã" });
          break;

case "mafias":
  {
    const activeGames = Object.values(mafiaDB)
      .filter(g => !g.started)
      .map(g => `üéÆ Partida: *${g.name}*\nüë• Jugadores: ${Object.keys(g.players).length}`)
      .join("\n\n");

    if (!activeGames) {
      return sock.sendMessage(from, { text: "üí¨ No hay partidas activas.", quoted: m });
    }

    return sock.sendMessage(from, { text: `üé≤ Partidas activas:\n\n${activeGames}`, quoted: m });
  }
break;

        case "comaf":
          await sock.sendMessage(from, { text: `üéÆ Comandos de Mafia:\n
#mafia crear ‚Üí Crear partida
#mafia entrar ‚Üí Entrarse a la partida
#mafia iniciar ‚Üí Iniciar juego y asignar roles
#mafia matar @user ‚Üí Solo lobos en la noche
#mafiaa ‚Üí Ver mafias
#mafia finnoches ‚Üí Terminar noche y pasar al d√≠a
#mafia votar @user ‚Üí Votar en d√≠a
#mafia findia ‚Üí Terminar d√≠a y eliminar al m√°s votado
#mafia estado ‚Üí Ver jugadores vivos y fase actual` });
          break;

case "chao":
          await sock.sendMessage(from, { text: "Goodbye Bitch\n> by :Jeffrey" });
          break;

        case "bucle":
          await sock.sendMessage(from, { text: "#bucle" });
          break;


        case "list": {
    const gachasText = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üé∞ LISTA GACHAS üé∞        
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üëë ‚ïê‚ïê‚ïê‚ïê ‚ú¶ DIVINE ‚ú¶ ‚ïê‚ïê‚ïê‚ïê üëë
‚ú¶ Madara Dios
‚ú¶ Zen‚Äô≈ç (Zeno-sama)
‚ú¶ Saitama
‚ú¶ Goku Instinto Ultra Maestro ‚óè‚Ä¢

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö´Ô∏è ‚ïê‚ïê‚ïê‚ïê ‚ú¶ OG ‚ú¶ ‚ïê‚ïê‚ïê‚ïê ‚ö´Ô∏è
‚ú¶ Iansini Prosini
‚ú¶ El Abrahaham
‚ú¶ Light Yagami
‚ú¶ Bonbon y Chuchu 
‚ú¶ Sonic El Pendejo ‚óè‚Ä¢

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö´Ô∏è ‚ïê‚ïê‚ïê‚ïê ‚ú¶ OG ??? ‚ú¶ ‚ïê‚ïê‚ïê‚ïê ‚ö™Ô∏è
‚ú¶ ¬ø ¬ø 67 ? ?

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ö™ ‚ïê‚ïê‚ïê‚ïê ‚ú¶ SECRETOS ‚ú¶ ‚ïê‚ïê‚ïê‚ïê ‚ö™
‚ú¶ Hinata Hyuga
‚ú¶ Son Gok≈´
‚ú¶ Naruto Uzumaki ‚óã

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üü† ‚ïê‚ïê‚ïê‚ïê ‚ú¶ √âPICOS ‚ú¶ ‚ïê‚ïê‚ïê‚ïê üü†
‚ú¶ Obito Uchiha
‚ú¶ Sakura Haruno
‚ú¶ Rock Lee
‚ú¶ Tenten
‚ú¶ Yamato
‚ú¶ Iruka Umino ‚óã¬∞

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üü¢ ‚ïê‚ïê‚ïê‚ïê ‚ú¶ COMUNES ‚ú¶ ‚ïê‚ïê‚ïê‚ïê üü¢
‚ú¶ Choji Akimichi
‚ú¶ Ino Yamanaka
‚ú¶ Sai
‚ú¶ Kurenai Yuhi
‚ú¶ Asuma Sarutobi
‚ú¶ Konohamaru Sarutobi

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üü° ‚ïê‚ïê‚ïê‚ïê ‚ú¶ RAROS ‚ú¶ ‚ïê‚ïê‚ïê‚ïê üü°
‚ú¶ Sasuke Uchiha
‚ú¶ Kakashi Hatake
‚ú¶ Gaara
‚ú¶ Shino Aburame
‚ú¶ Kiba Inuzuka

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéÆ Usa *#rw* para invocar
üçÄ La suerte decide tu destino
`;

    await sock.sendMessage(from, { text: gachasText });
}
break;

case 'pregunta': {
    const preguntas = [
        "¬øQui√©n te gusta del grupo? üëÄ",
        "¬øTu mayor verg√ºenza? üò≥",
        "¬øA qui√©n eliminar√≠as del grupo? üòà",
        "¬øHas stalkeado a alguien aqu√≠? üì±",
        "¬øMentiste hoy? ü§•"
    ];

    const pregunta = preguntas[Math.floor(Math.random() * preguntas.length)];

    await sock.sendMessage(from, {
        text: `‚ùì *PREGUNTA*\n\n${pregunta}`
    });
    break;
}

case 'reto': {
    const retos = [
        "Env√≠a un audio cantando üé§",
        "Cambia tu foto por 10 minutos üñºÔ∏è",
        "Etiqueta a alguien que te caiga bien üòè",
        "Di una verdad inc√≥moda üò≥",
        "Escribe sin usar vocales por 5 mensajes ü§ê"
    ];

    const reto = retos[Math.floor(Math.random() * retos.length)];

    await sock.sendMessage(from, {
        text: `üéØ *RETO*\n\n${reto}`
    });
    break;
}

case 'reto:3': {
  const retos = [
    "Mandar un audio cantando como oveja owo",
    "Decir algo cursi",
    "Llamar a un Random",
    "Declararse a un amigo/a",
    "Ver un v√≠deo de Fede vigevani XD"
  ];
  const reto = retos[Math.floor(Math.random() * retos.length)];
  await sock.sendMessage(from, { text: `${reto} \n> by :Jeffrey` });
  break;
}

case 'reto:1': {
  const retos = [    "Ver un v√≠deo de Fede vigevani XD"  ];
  
    const reto = retos[Math.floor(Math.random() * retos.length)];
  await sock.sendMessage(from, { text: `${reto} \n> by :Ian` });
  break;
}

case "promote": {
    if (!isGroup) return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants.filter(p => p.admin !== null).map(p => p.id);
    if (!adminIds.includes(sender)) return await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });

    const botParticipant = groupMeta.participants.find(p => p.id === sock.user.id);
    const isBotAdmin = botParticipant?.admin !== null;
    if (!isBotAdmin) return await sock.sendMessage(from, { text: "‚ùå Necesito ser admin para promover a alguien." });

    const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0) return await sock.sendMessage(from, { text: "‚ùå Menciona a alguien para promoverlo." });

    for (let jid of mentioned) {
        await sock.groupParticipantsUpdate(from, [jid], "promote");
    }

    // Construir mensaje de aviso
    const senderName = pushName || "Alguien";
    let message = '';
    for (let jid of mentioned) {
        const userName = jid.split('@')[0];
        message += `‚ö†Ô∏è Aviso: @${userName} ahora es admin\n> Acci√≥n hecha por *@${senderName}*\n\n`;
    }

    await sock.sendMessage(from, {
        text: message,
        mentions: [...mentioned, sender]
    });
}
break;

case 'report': {
    try {
        if (!args.length) {
            return await sock.sendMessage(from, {
                text:
`üßæ *Reporte de errores*
Usa:
#report <describe el problema>

Ej:
#report el comando play no manda audio`
            }, { quoted: msg });
        }

        const reporte = args.join(" ");

        const textoOwner =
`üö® *NUEVO REPORTE*

üë§ Usuario: ${pushName || "Sin nombre"}
üì± JID: ${sender}
üìç Chat: ${isGroup ? "Grupo" : "Privado"}
üìù Reporte:
${reporte}`.trim();

        // Enviar al OWNER
        await sock.sendMessage(OWNER, {
            text: textoOwner
        });

        // Confirmaci√≥n al usuario
        await sock.sendMessage(from, {
            text: "‚úÖ Tu reporte fue enviado al creador, Lo veremos lo mas pronto posible"
        }, { quoted: msg });

    } catch (e) {
        console.log("REPORT ERROR:", e);
        await sock.sendMessage(from, {
            text: "‚ùå No se pudo enviar el reporte."
        }, { quoted: msg });
    }
    break;
}

case 'sugerrw':
case 'votar':
case 'vote': {
    try {
        if (!args.length) {
            return await sock.sendMessage(from, {
                text:
`*Sugerir Roll ( ‚âß‚àÄ‚â¶)„Éé*
Usa:#vote *personaje*

> ej: #vote Ayase Nagatoro`
            }, { quoted: msg });
        }

        const reporte = args.join(" ");

        const textoOwner =
`‚ùñ‚èî‚ùñNUEVA SUGERENCIA‚ùñ‚èî‚ùñ

‚ùñ Usuario: ${pushName || "Sin nombre"}
‚ùñ ID: ${sender}
‚ùñ Chat: ${isGroup ? "Grupo" : "Privado"}
‚ùñ Sugerencia:
${reporte}`.trim();

        // Enviar al OWNER
        await sock.sendMessage(OWNER, {
            text: textoOwner
        });

        // Confirmaci√≥n al usuario
        await sock.sendMessage(from, {
            text: "‚úÖ Tu sugerencia fue enviada al creador, Lo veremos lo mas pronto posible"
        }, { quoted: msg });

    } catch (e) {
        console.log("SUGERENCIA ERROR:", e);
        await sock.sendMessage(from, {
            text: "‚ùå No se pudo enviar el reporte."
        }, { quoted: msg });
    }
    break;
}


case "demote": {
    if (!isGroup) return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants.filter(p => p.admin !== null).map(p => p.id);
    if (!adminIds.includes(sender)) return await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });

    const botParticipant = groupMeta.participants.find(p => p.id === sock.user.id);
    const isBotAdmin = botParticipant?.admin !== null;
    if (!isBotAdmin) return await sock.sendMessage(from, { text: "‚ùå Necesito ser admin para degradar a alguien." });

    const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0) return await sock.sendMessage(from, { text: "‚ùå Menciona a alguien para quitarle el admin." });

    for (let jid of mentioned) {
        await sock.groupParticipantsUpdate(from, [jid], "demote");
    }

    // Construir mensaje de aviso
    const senderName = pushName || "Alguien";
    let message = '';
    for (let jid of mentioned) {
        const userName = jid.split('@')[0];
        message += `‚ö†Ô∏è Aviso: @${userName} dej√≥ de ser admin\n> Acci√≥n hecha por *@${senderName}* \n\n`;
    }

    await sock.sendMessage(from, {
        text: message,
        mentions: [...mentioned, sender]
    });
}
break;



 case 'admin':
    // Verificar si mencionaron a alguien
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
    if (mentioned.length === 0) {
        await sock.sendMessage(from, { text: '‚ùå Etiqueta a alguien para usar este comando' });
        break;
    }

    const senderName = pushName || 'Alguien';
    
    // Construir el mensaje
    let message = '';
    for (let i = 0; i < mentioned.length; i++) {
        const userJid = mentioned[i];
        const userName = userJid.split('@')[0];
        message += `@${userName} @${senderName} te tir√≥ admin panel üòé\n`;
    }

    // Enviar mensaje con imagen
    await sock.sendMessage(from, {
        image: { url: 'https://i.postimg.cc/x11C2TfY/Screenshot-20251129-173850-You-Tube.jpg' }, // <-- Pon aqu√≠ tu imagen
        caption: message,
        mentions: mentioned
    });
    break;
   
case "nsfw": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        await sock.sendMessage(from, { text: "‚ùå Solo en grupos." });
        break;
    }

    const groupMeta = await sock.groupMetadata(from);
    const admins = groupMeta.participants
        .filter(p => p.admin)
        .map(p => p.id);

    // ‚ùå No admin
    if (!admins.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        await sock.sendMessage(from, {
            text: "‚ùå Solo admins pueden usar este comando."
        });
        break;
    }

    const option = args[0];

    // ‚úÖ Es admin y el comando es v√°lido
    if (option === "on") {
        await sock.sendMessage(from, {
            react: { text: "‚úÖ", key: msg.key }
        });

        global.nsfwGroups[from] = true;
        saveNSFW();
        await sock.sendMessage(from, { text: "üîû NSFW ACTIVADO" });
    } 
    else if (option === "off") {
        await sock.sendMessage(from, {
            react: { text: "‚úÖ", key: msg.key }
        });

        delete global.nsfwGroups[from];
        saveNSFW();
        await sock.sendMessage(from, { text: "üö´ NSFW DESACTIVADO" });
    } 
    else {
        await sock.sendMessage(from, {
            react: { text: "‚ö†Ô∏è", key: msg.key }
        });

        await sock.sendMessage(from, {
            text: "Usa:\n#nsfw on\n#nsfw off"
        });
    }
    break;
}
     
case 'ass': {
    if (!isGroup) {
        await sock.sendMessage(from, { text: "‚ùå Solo en grupos." });
        break;
    }

    if (!global.nsfwGroups?.[from]) {
        await sock.sendMessage(from, {
            text: "üîû NSFW desactivado.\nUn admin debe usar *#nsfw on*"
        });
        break;
    }

    try {
        const res = await fetch("https://api.waifu.pics/nsfw/ass");
        const data = await res.json();

        if (!data?.url) throw new Error("No URL");

        await sock.sendMessage(from, {
            image: { url: data.url },
            caption: "üçë Ass"
        });
    } catch (e) {
        console.error(e);
        await sock.sendMessage(from, { text: "‚ùå Error NSFW." });
    }
    break;
}



case 'boobs': {
    if (!isGroup) {
        await sock.sendMessage(from, { text: "‚ùå Solo en grupos." });
        break;
    }

    if (!global.nsfwGroups?.[from]) {
        await sock.sendMessage(from, {
            text: "üîû NSFW desactivado.\nUn admin debe usar *#nsfw on*"
        });
        break;
    }

    try {
        const res = await fetch("https://nekobot.xyz/api/image?type=boobs");
        const data = await res.json();

        if (!data?.message) throw new Error("No image");

        await sock.sendMessage(from, {
            image: { url: data.message },
            caption: "üçí Boobs"
        });
    } catch (e) {
        console.error(e);
        await sock.sendMessage(from, { text: "‚ùå Error NSFW." });
    }
    break;
}


     
case "menus":
case "menu":
case "help": {
    const saludo = saludoPorHora();

    const thumb = await fs.readFileSync("./image.jpg"); // o el thumbnail que quieras

   
    
    await sock.sendMessage(from, {

        text: menuText
            .replace("@@USER", `@${sender.split("@")[0]}`)
            .replace("@@SALUDO", saludo),

        mentions: [sender],

        contextInfo: {
            isForwarded: true,
            forwardingScore: 1,

            forwardedNewsletterMessageInfo: {
                newsletterJid: "120363422781423966@newsletter",
                newsletterName: "üåπCrizZappüåπ",
                serverMessageId: 1
            },

            externalAdReply: {
                title: "ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ",
                body: "api.crisbots.com",
                thumbnail: thumb,
                sourceUrl: "https://whatsapp.com/channel/0029VbBN8qCG3R3cZASjRO1I",
                mediaType: 1,
                renderLargerThumbnail: true
 
            }
        }
      }, { quoted: msg });
    await sock.sendMessage(from, {

    react: { text: "üñº", key: msg.key }
    });
    
}
break;

case "ayuda": {
  const userTag = `@${sender.split("@")[0]}`;

  const ayudaTexto =
`üëã ¬°Hola ${userTag}!

ü§ñ Soy *üÖÇüÑ∑üÑæüÑ∫üÑæ üÑ∫üÑæüÑºüÑ∏*, un Bot de WhatsApp
üõ†Ô∏è Desarrollado por *CrizZapp*

üìå Comandos b√°sicos:
‚Ä¢ Usa *#help* para ver el men√∫ completo
‚Ä¢ Usa *#report* para enviar sugerencias o errores

üß∏ Espero que te sea √∫til y si no, gracias por usar el bot üåπ`;

  // üì© Enviar al PRIVADO (respondiendo al mensaje original)
  await sock.sendMessage(
    sender,
    {
      text: ayudaTexto,
      mentions: [sender]
    },
    { quoted: msg }
  );

  // üí¨ Aviso en el chat donde se us√≥ (tambi√©n respondiendo)
  await sock.sendMessage(
    from,
    {
      text: "üì© Te envi√© la informaci√≥n al privado."
    },
    { quoted: msg }
  );

  break;
}

case "menus":
case "menu":
case "help": {
    const saludo = saludoPorHora();

    const thumb = await fs.readFileSync("./image.jpg"); // o el thumbnail que quieras

   
    
    await sock.sendMessage(from, {

        text: menuText
            .replace("@@USER", `@${sender.split("@")[0]}`)
            .replace("@@SALUDO", saludo),

        mentions: [sender],

        contextInfo: {
            isForwarded: true,
            forwardingScore: 1,

            forwardedNewsletterMessageInfo: {
                newsletterJid: "120363422781423966@newsletter",
                newsletterName: "‚òºüåπCrizZappüåπ‚òº",
                serverMessageId: 1
            },

            externalAdReply: {
                title: "ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ",
                body: "api.crisbots.com",
                thumbnail: thumb,
                sourceUrl: "https://whatsapp.com/channel/0029VbBN8qCG3R3cZASjRO1I",
                mediaType: 1,
                renderLargerThumbnail: true
 
            }
        }
      }, { quoted: msg });
    await sock.sendMessage(from, {

    react: { text: "üñº", key: msg.key }
    });
    
}
break;



case "owner":
case "creador": {
    const saludo = saludoPorHora();

   
    
    await sock.sendMessage(from, {

        text: `¬∞‚ãÜ.‡≥É Hola üòå @@USER 

Soy el creador de *Shoko Komi BOT*
Estoy aprendiendo a desarrollar bots de WhatsApp ‡≥É.‚ãÜ¬∞

*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ãÜ‚ãÖ‚òÜ‚ãÖ‚ãÜ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*

üìå *Informaci√≥n*
üë§ Nombre: Cris
üéÑ Versi√≥n del bot:üåÉA√±o nuevo *2026*
üìû N√∫mero: +59898476523

*‚´ò‚´ò‚´ò‚´ò„Ää‚ô±„Äã‚´ò‚´ò‚´ò‚´ò‚´ò*

üß∏ ~Sigue el canal~ üß∏: `
            .replace("@@USER", `@${sender.split("@")[0]}`)
            .replace("@@SALUDO", saludo),

        mentions: [sender],

        contextInfo: {
            isForwarded: true,
            forwardingScore: 2,

            forwardedNewsletterMessageInfo: {
                newsletterJid: "120363422781423966@newsletter",
                newsletterName: "ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ",
                serverMessageId: 1
            }
        }
      }, { quoted: msg });
    await sock.sendMessage(from, {

    react: { text: "ü§¶", key: msg.key }
    });
    
}
break;


case "code":
case "serbot": {
    const saludo = saludoPorHora();

   
    
    await sock.sendMessage(from, {

        text: "„Ää‚úß„Äã No se han encontrado espacios disponibles para registrar un `Sub-Bot`.\n> Por favor intenta en unos minutos."
            .replace("@@USER", `@${sender.split("@")[0]}`)
            .replace("@@SALUDO", saludo),

        mentions: [sender],

        contextInfo: {
            isForwarded: true,
            forwardingScore: 2,

            forwardedNewsletterMessageInfo: {
                newsletterJid: "120363422781423966@newsletter",
                newsletterName: "ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ",
                serverMessageId: 1
            }
        }
      }, { quoted: msg });
    await sock.sendMessage(from, {

    react: { text: "ü§¶", key: msg.key }
    });
    
}
break;


case 'veteranff': {
    if (!args[0]) {
        await sock.sendMessage(from, {
            text: '‚ùå Usa el comando as√≠:\n#veteranff <ID>'
        });
        break;
    }

    const id = parseInt(args[0]);
    if (isNaN(id)) {
        await sock.sendMessage(from, {
            text: '‚ùå El ID debe ser un n√∫mero v√°lido.'
        });
        break;
    }

    let porcentaje;
    let epoca;

    if (id < 50000000) {
        porcentaje = Math.floor(Math.random() * (100 - 90 + 1)) + 90;
        epoca = '2018 ‚Äì 2019';
    } else if (id < 150000000) {
        porcentaje = Math.floor(Math.random() * (89 - 70 + 1)) + 70;
        epoca = '2019 ‚Äì 2020';
    } else if (id < 300000000) {
        porcentaje = Math.floor(Math.random() * (69 - 40 + 1)) + 40;
        epoca = '2020 ‚Äì 2021';
    } else if (id < 600000000) {
        porcentaje = Math.floor(Math.random() * (39 - 15 + 1)) + 15;
        epoca = '2021 ‚Äì 2022';
    } else {
        porcentaje = Math.floor(Math.random() * 15);
        epoca = '2023+';
    }

    const barras = '‚ñ∞'.repeat(Math.floor(porcentaje / 10)) + '‚ñ±'.repeat(10 - Math.floor(porcentaje / 10));

    const mensaje = `
üéÆ *An√°lisis Free Fire*

üÜî ID: ${id}

üìä *Antig√ºedad estimada*
${barras} ${porcentaje}%

üï∞Ô∏è √âpoca aproximada:
${epoca}

‚ö†Ô∏è Este resultado es una estimaci√≥n
basada en rangos de ID.
`.trim();

    await sock.sendMessage(from, { text: mensaje });
    break;
}

case "w":
case "work": {
    await sock.sendMessage(from, {
        react: { text: "üïµ‚Äç‚ôÇÔ∏è", key: msg.key }
    });

    await economia.cmdWork(
        sock,
        from,
        sender,
        pushName
    );

    break;
}

case "pay":
case "give":
case "givecoins": {
    const channelInfo = {
        isForwarded: true,
        forwardingScore: 2,
        forwardedNewsletterMessageInfo: {
            newsletterJid: "120363422781423966@newsletter",
            newsletterName: "‚òºCris Bot - oficial channel‚úß",
            serverMessageId: 1
        }
    };

    const mentioned = getMentionedJid(msg);
    const amount = args[1];

    // MENSAJE ANCLA (canal)
    await sock.sendMessage(
        from,
        {
            text: "üí∏ Procesando transferencia...",
            contextInfo: channelInfo
        },
        { quoted: msg }
    );

    if (!mentioned) {
        await sock.sendMessage(from, {
            text: "‚ùå Debes mencionar a alguien.\nEjemplo:\n#givecoins @usuario 500",
            contextInfo: channelInfo
        });
        break;
    }

    // Reacci√≥n
    await sock.sendMessage(from, {
        react: { text: "üí∑", key: msg.key }
    });

    await economia.cmdGiveCoins(
        sock,
        from,
        sender,
        mentioned,
        amount,
        pushName,
        async (msgText) => {
            await sock.sendMessage(from, {
                text: msgText,
                contextInfo: {
                    ...channelInfo,
                    mentions: [mentioned]
                }
            });
        }
    );

    break;
}

case "bal":
case "balance": {
    const channelInfo = {
        isForwarded: true,
        forwardingScore: 2,
        forwardedNewsletterMessageInfo: {
            newsletterJid: "120363422781423966@newsletter",
            newsletterName: "‚òºCris Bot - oficial channel‚úß",
            serverMessageId: 1
        }
    };

    // Mensaje inicial
    await sock.sendMessage(
        from,
        {
            text: "Buscando..",
            contextInfo: channelInfo
        },
        { quoted: msg }
    );

    // Reacci√≥n
    await sock.sendMessage(from, {
        react: { text: "üïµ‚Äç‚ôÇÔ∏è", key: msg.key }
    });

    // Resultado del trabajo (tambi√©n con canal)
    await economia.cmdBal(
        sock,
        from,
        sender,
        pushName,
        async (msgText) => {
            await sock.sendMessage(from, {
                text: msgText,
                contextInfo: channelInfo
            });
        }
    );

    break;
}



case "buyvip": {
    await sock.sendMessage(from, { react: { text: "‚úîÔ∏è", key: msg.key } });
    await economia.cmdBuyVip(sock, from, sender, pushName, async (msg) => 
        await sock.sendMessage(from, { text: msg })
    );
    break;
}

case "daily": {
    await sock.sendMessage(from, {
        react: { text: "üéÅ", key: msg.key }
    });

    await economia.cmdDaily(
        sock,
        from,
        sender,
        pushName,
        async (msgText) => {
            await sock.sendMessage(
                from,
                {
                    text: msgText,
                    contextInfo: channelInfo
                },
                { quoted: msg }
            );
        }
    );

    break;
}

case "fish": {
    await sock.sendMessage(from, {
        react: { text: "üé£", key: msg.key }
    });

    await economia.cmdFish(
        sock,
        from,
        sender,
        pushName,
        async (msgText) => {
            await sock.sendMessage(
                from,
                {
                    text: msgText,
                    contextInfo: channelInfo
                },
                { quoted: msg }
            );
        }
    );

    break;
}

case "perfil":
case "profile": {
    await sock.sendMessage(from, {
        react: { text: "üßë‚Äç‚öñÔ∏è", key: msg.key }
    });

    await cmdPerfil(
        sock,
        from,
        sender,
        pushName
    );

    break;
}

case "steal": {
    await sock.sendMessage(from, { react: { text: "ü•∑", key: msg.key } });

    if (args.length < 1) {
        await sock.sendMessage(from, { text: "‚ùå Debes poner el ID del usuario a robar." });
        break;
    }

    const target = args[0];
    await economia.cmdStealCoins(sock, from, sender, pushName, async (msg) => {
        await sock.sendMessage(from, { text: msg });
    }, target);

    break;
}

case "regalo": {
  const coins = Math.floor(Math.random() * 500) + 100;

  await sock.sendMessage(from, {
    text: `üéÅ‚ú® REGALO NAVIDE√ëO ‚ú®üéÅ

üéÑ Has recibido: *${coins} coins*
üéÖ Vuelve ma√±ana por otro regalo

¬°Feliz Navidad! ‚ùÑÔ∏è`
  });
  break;
}

case "botoff":
case "bangp": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, { react: { text: "üö´", key: msg.key } });
        await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });
        break;
    }

    // ‚úÖ Obtener admins del grupo
    const meta = await sock.groupMetadata(from);
    const adminIds = meta.participants.filter(p => p.admin !== null).map(p => p.id);

    // ‚ùå No es admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, { react: { text: "üö´", key: msg.key } });
        await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });
        break;
    }

    // ‚úÖ Bannear grupo
    gruposBaneados.add(from);
    await sock.sendMessage(from, { react: { text: "‚úÖ", key: msg.key } });
    await sock.sendMessage(from, { text: "‚úÖ Este grupo ha sido baneado. No responder√© m√°s aqu√≠." });
    break;
}

case "boton":
case "unbangp": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, { react: { text: "üö´", key: msg.key } });
        await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });
        break;
    }

    // ‚úÖ Obtener admins del grupo
    const meta = await sock.groupMetadata(from);
    const adminIds = meta.participants.filter(p => p.admin !== null).map(p => p.id);

    // ‚ùå No es admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, { react: { text: "üö´", key: msg.key } });
        await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });
        break;
    }

    // ‚úÖ Desbanear grupo
    gruposBaneados.delete(from);
    await sock.sendMessage(from, { react: { text: "‚úÖ", key: msg.key } });
    await sock.sendMessage(from, { text: "‚úÖ El grupo ha sido desbaneado. Volver√© a responder aqu√≠." });
    break;
}

case "add":
case "a√±adir": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });
        return;
    }

    // ‚ùå No pas√≥ n√∫mero
    if (!args[0]) {
        await sock.sendMessage(from, { text: "‚ùå Uso: #add 598XXXXXXXX" });
        return;
    }

    // Limpiar n√∫mero
    const number = args[0].replace(/\D/g, "");
    const user = number + "@s.whatsapp.net";

    // Obtener admins del grupo
    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    // ‚ùå Usuario no es admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });
        return;
    }

    try {
        // Intentar a√±adir
        await sock.groupParticipantsUpdate(from, [user], "add");
        await sock.sendMessage(from, { text: `‚úÖ @${number} fue a√±adido al grupo.`, mentions: [user] });
    } catch (err) {
        console.error("Error add:", err);
        // Mostrar error real
        if (err.message.includes("bad-request")) {
            await sock.sendMessage(from, { text: "‚ùå No se pudo a√±adir: WhatsApp requiere que el bot tenga el n√∫mero guardado." });
        } else {
            await sock.sendMessage(from, { text: `‚ùå No se pudo a√±adir: ${err.message}` });
        }
    }
    break;
}

        case "miid":
          await sock.sendMessage(from, { text: `Tu JID es: ${sender}` });
          break;

case "close":
case "#close": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Este comando solo funciona en grupos."
        });
    }

    // Obtener admins
    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    // ‚ùå No admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Solo un admin puede cerrar el grupo."
        });
    }

    // ‚úÖ Es admin ‚Üí cerrar grupo
    await sock.sendMessage(from, {
        react: { text: "‚úÖ", key: msg.key }
    });

    await sock.groupSettingUpdate(from, "announcement");

    await sock.sendMessage(from, {
        text: "üîí *Grupo cerrado*\nSolo los admins pueden enviar mensajes."
    });

    break;
}

case "banbot": {
  if (sender !== OWNER_JID)
    return sock.sendMessage(from, { text: "‚ùå Solo el OWNER puede usar este comando." });

  const user = mentionedJid?.[0];
  if (!user)
    return sock.sendMessage(from, { text: "‚ö†Ô∏è Menciona a alguien." });

  banUser(user);

  await sock.sendMessage(from, {
    text: `üö´ @${user.split("@")[0]} fue *baneado del bot*.`,
    mentions: [user]
  });
  break;
}

case "unbanbot": {
  if (sender !== OWNER_JID)
    return sock.sendMessage(from, { text: "‚ùå Solo el OWNER puede usar este comando." });

  const user = mentionedJid?.[0];
  if (!user)
    return sock.sendMessage(from, { text: "‚ö†Ô∏è Menciona a alguien." });

  unbanUser(user);

  await sock.sendMessage(from, {
    text: `‚úÖ @${user.split("@")[0]} fue *desbaneado del bot*.`,
    mentions: [user]
  });
  break;
}

case "del":
case "delete": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Este comando solo funciona en grupos."
        });
    }

    // ‚ùå Debe responder a un mensaje
    const ctx = msg.message?.extendedTextMessage?.contextInfo;
    if (!ctx?.stanzaId || !ctx?.participant) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Responde al mensaje que quieres eliminar."
        });
    }

    // Obtener admins (IGUAL que #close)
    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    // ‚ùå Usuario no admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Solo un admin puede borrar mensajes."
        });
    }

    // ‚úÖ Intentar borrar (WhatsApp decide si el bot puede)
    try {
        await sock.sendMessage(from, {
            delete: {
                remoteJid: from,
                fromMe: false,
                id: ctx.stanzaId,
                participant: ctx.participant
            }
        });

        await sock.sendMessage(from, {
            react: { text: "‚úÖ", key: msg.key }
        });

        await sock.sendMessage(from, {
            text: "üóëÔ∏è *Acci√≥n hecha*"
        });

    } catch (e) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });

        await sock.sendMessage(from, {
            text: "‚ùå No se pudo borrar el mensaje (¬øel bot no es admin?)."
        });
    }

    break;
}

case "open":
case "#open": {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Este comando solo funciona en grupos."
        });
    }

    // Obtener admins
    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    // ‚ùå No admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Solo un admin puede abrir el grupo."
        });
    }

    // ‚úÖ Es admin ‚Üí abrir grupo
    await sock.sendMessage(from, {
        react: { text: "‚úÖ", key: msg.key }
    });

    await sock.groupSettingUpdate(from, "not_announcement");

    await sock.sendMessage(from, {
        text: "üîì *Grupo abierto*\nTodos pueden enviar mensajes."
    });

    break;
}



case "mute": {
    if (!isGroup)
        return sock.sendMessage(from, { text: "‚ùå Solo en grupos." });

    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    if (!adminIds.includes(sender))
        return sock.sendMessage(from, { text: "‚ùå Solo admins." });

    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0)
        return sock.sendMessage(from, { text: "‚ùå Menciona a alguien." });

    mentioned.forEach(u => mutedUsers.add(u));

    await sock.sendMessage(from, {
        text: `üîá ${mentioned.map(u => "@" + u.split("@")[0]).join(", ")} fue muteado.`,
        mentions: mentioned
    });
    break;
}

case "escopeta":
  try {
    await sock.sendMessage(from, {
      audio: { url: "./media/escopeta.mp3" },
      mimetype: "audio/mpeg",
      ptt: false
    });
  } catch (e) {
    console.log("Error enviando el audio:", e);
  }
break;

case "tralalerita":
  try {
    await sock.sendMessage(from, {
      audio: { url: "./media/tralalerita.mp3" },
      mimetype: "audio/mpeg",
      ptt: false
    });
  } catch (e) {
    console.log("Error enviando el audio:", e);
  }
break;

case "fuentes":
case "fonts": {
    // ‚ùå Sin texto
    if (!args || args.length === 0) {
        await sock.sendMessage(from, { text: "‚úèÔ∏è *Ejemplo:* #fuentes hola bro" });
        break;
    }

    // Texto limpio
    const clean = args.join(" ");

    // Array de funciones de fuentes
    const fonts = [
        (t) => t.toUpperCase(),
        (t) => t.toLowerCase(),
        (t) => `ùôÅùô§ùô£ùô©: ${t.replace(/[a-z]/gi, c => String.fromCharCode(c.charCodeAt(0) + 0x1D00))}`,
        (t) => `‚òÖÂΩ° ${t} ÂΩ°‚òÖ`,
        (t) => `„Äé ${t} „Äè`,
        (t) => `‚ú¶‚Ä¢¬∑¬∑¬∑¬∑¬∑¬∑‚Ä¢ ${t} ‚Ä¢¬∑¬∑¬∑¬∑¬∑¬∑‚Ä¢‚ú¶`,
        (t) => `‚ú® ${t} ‚ú®`,
        (t) => `‚û§ ${t} ‚óÑ`,
    ];

    // Mensaje inicial
    await sock.sendMessage(from, { text: `‚ú® *FUENTES PARA:* ${clean}` });

    // Mandar cada fuente
    for (let i = 0; i < fonts.length; i++) {
        await sock.sendMessage(from, { text: `*${i + 1}.* ${fonts[i](clean)}` });
    }

    // Reacci√≥n al final
    await sock.sendMessage(from, {
        react: { text: "üî†", key: msg.key }
    });

    break;
}

case "waifu": {
  try {
    const res = await axios.get("https://api.waifu.pics/sfw/waifu");

    await sock.sendMessage(from, {
      image: { url: res.data.url },
      caption: "‚ú® Imagen anime"
     });
    //Reaccion
        await sock.sendMessage(from, {
        react: { text: "‚ù§Ô∏è‚Äçüî•", key: msg.key }
    });
  } catch (e) {
    await sock.sendMessage(from, {
      text: "‚ùå Error al obtener la imagen."
    });
  }
}
break;

  case "gachas":
  case "#gachas":
    await cmdPublicarGacha(sock, msg);
  break;

  case "gacha":
  case "#gacha":
    await cmdGacha(sock, from, sender);
  break;

  case "claimgacha":
  case "gclaim":
    await cmdClaim(sock, from, sender);
  break;


case "hora":
    {
        const fecha = new Date();
        const opciones = {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false,
            timeZone: 'America/Montevideo' // Cambialo si est√°s en otra zona horaria
        };
        const horaActual = fecha.toLocaleString('es-ES', opciones);

        await sock.sendMessage(from, { text: `üïí Hora y fecha actual:\n${horaActual}` });
    //Reaccion
        await sock.sendMessage(from, {
        react: { text: "‚åöÔ∏è", key: msg.key }
    });
    }
    break;

case "einfo":
  await economia.cmdEinfo(sock, from, sender, m);
  break;
  
  case "lyrics":
case "lyric":
case "cancion": {
    try {
        const query = args.join(" ");
        if (!query) {
            await sock.sendMessage(from, {
                text: "‚ùå Escribe el nombre de la canci√≥n.\nEj: #lyrics Milo J Ni√±o"
            });
            break;
        }

        await sock.sendMessage(from, {
            text: `üéµ Buscando letra de: *${query}*...`
        });

        // Buscar en YouTube
        const search = await ytSearch(query);
        if (!search.videos || !search.videos.length) {
            await sock.sendMessage(from, { text: "‚ùå No encontr√© resultados." });
            break;
        }

        let title = search.videos[0].title;

        // LIMPIEZA DEL T√çTULO
        title = title
            .replace(/\(.*?\)/g, "")
            .replace(/\[.*?\]/g, "")
            .replace(/official.*$/i, "")
            .replace(/video.*$/i, "")
            .replace(/lyrics.*$/i, "")
            .trim();

        // Separar artista - canci√≥n
        let artist = "";
        let song = "";

        if (title.includes("-")) {
            [artist, song] = title.split("-").map(t => t.trim());
        } else {
            song = title;
            artist = search.videos[0].author?.name || "";
        }

        if (!artist || !song) {
            await sock.sendMessage(from, {
                text: "‚ùå No pude identificar artista y canci√≥n."
            });
            break;
        }

        const url = `https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(song)}`;
        const res = await axios.get(url);

        if (!res.data?.lyrics) {
            await sock.sendMessage(from, {
                text: "‚ùå Letra no encontrada."
            });
            break;
        }

        const lyrics = res.data.lyrics.slice(0, 3800); // evita l√≠mite WA

        await sock.sendMessage(from, {
            text:
`üé§ *${song}*
üë§ *Artista:* ${artist}

${lyrics}`
        });

    } catch (e) {
        console.error("Error en #lyrics:", e);
        await sock.sendMessage(from, {
            text: "‚ùå Error buscando la letra."
        });
    }
    break;
}

case "yt":
case "video":
    try {
        const query = args.join(" ");
        if (!query)
            return sock.sendMessage(from, { text: "‚ùó Escribe el nombre del video o link." });

        let url = query;
        const isLink = /(youtube\.com|youtu\.be)/i.test(query);
        let video;

        if (!isLink) {
            await sock.sendMessage(from, { text: `üîé Buscando *${query}*...` });

            const search = await ytSearch(query);
            if (!search.videos.length)
                return sock.sendMessage(from, { text: "‚ùå No encontr√© resultados." });

            video = search.videos[0];
            url = video.url;
        } else {
            // Extraer el ID del link
            const idMatch = url.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/);
            const videoId = idMatch ? idMatch[1] : "default";

            video = {
                title: "Video de YouTube",
                duration: "Desconocido",
                thumbnail: `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`,
                author: { name: "Desconocido" },
                views: "Desconocidas"
            };
        }

        const thumb = await getBuffer(video.thumbnail);
        const views = video.views ? video.views.toLocaleString("en-US") : "N/A";

        await sock.sendMessage(from, {
            image: thumb,
            caption: `üé¨ *${video.title}*\nüßë‚Äçüé§ Creador: *${video.author?.name}*\nüëÅÔ∏è Visitas: *${views}*\n‚è±Ô∏è Duraci√≥n: *${video.duration}*\n\nüì• *Preparando el video...*`
        });

        const output = `/sdcard/${Date.now()}.mp4`;

        exec(`yt-dlp -f "best[height<=720]" -o "${output}" "${url}"`, async (err) => {
            if (err) {
                console.log(err);
                return sock.sendMessage(from, { text: "‚ùå Error descargando el video." });
            }

            await sock.sendMessage(from, {
                video: { url: output },
                caption: "üé• Aqu√≠ tienes tu video."
            });

            fs.unlinkSync(output);
        });

    } catch (e) {
        console.log("Error #yt:", e);
        sock.sendMessage(from, { text: "‚ùå Error procesando el comando." });
    }
break;

case "tiktok":
case "tt":
    try {
        const query = args.join(" ");
        if (!query) return sock.sendMessage(from, { text: "‚ùó Escribe el nombre del TikTok o una b√∫squeda." });

        await sock.sendMessage(from, { text: `üéµ Buscando en TikTok: *${query}*...` });

        // 1. Buscar en TikTok usando yt-dlp
        exec(`yt-dlp "ytsearch1:${query} tiktok" --dump-json`, async (err, stdout) => {
            if (err || !stdout) {
                console.log("Error b√∫squeda TikTok:", err);
                return sock.sendMessage(from, { text: "‚ùå No encontr√© ning√∫n TikTok relacionado." });
            }

            const info = JSON.parse(stdout);
            const url = info.webpage_url;
            const title = info.title || "TikTok";

            await sock.sendMessage(from, { text: `‚¨áÔ∏è Descargando TikTok...\nüìπ *${title}*` });

            // 2. Descargar el video
            const output = `/sdcard/${Date.now()}.mp4`;

            exec(`yt-dlp -f mp4 --no-warnings -o "${output}" "${url}"`, async (err2) => {
                if (err2) {
                    console.log("Error descargando TikTok:", err2);
                    return sock.sendMessage(from, { text: "‚ùå Error descargando el TikTok." });
                }

                // 3. Enviar el video
                await sock.sendMessage(from, {
                    video: { url: output },
                    caption: title
                });
            });
        });

    } catch (e) {
        console.log("Error #tiktok:", e);
        sock.sendMessage(from, { text: "‚ùå Error procesando el comando." });
    }
break;


case "s":
case "sticker": {
    try {
        const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;

        const media =
            msg.message?.imageMessage ||
            msg.message?.videoMessage ||
            quoted?.imageMessage ||
            quoted?.videoMessage;

        if (!media) {
            return sock.sendMessage(from, {
                text: "‚ùå Env√≠a o responde una imagen o video (m√°x 10s)."
            });
        }

        if (media.seconds && media.seconds > 10) {
            return sock.sendMessage(from, { 
                text: "‚è±Ô∏è El video no puede pasar 10 segundos." 
            });
        }

        await sock.sendMessage(from, { text: "‚ú® Creando sticker..." });

        // Descargar buffer universal
        const buffer = await descargarMedia(msg);
         if (!buffer) throw new Error("Error descargando media");

        const base = Date.now();
        const input = `/sdcard/st_${base}.${media.mimetype.startsWith("video") ? "mp4" : "jpg"}`;
        const output = `/sdcard/st_${base}.webp`;

        fs.writeFileSync(input, buffer);

        // ffmpeg para convertir imagen o video ‚Üí webp
        const font = "/system/fonts/Roboto-Regular.ttf";
const text = "by CrisBot";
const cmd = media.mimetype.startsWith("video")
? `ffmpeg -i '${input}' -vf "drawtext=fontfile=${font}:text='${text}':fontcolor=white:fontsize=24:shadowcolor=black:shadowx=2:shadowy=2:x=w-tw-10:y=10" -vcodec libwebp -loop 0 -preset default -an -vsync 0 '${output}'`
: `ffmpeg -i '${input}' -vf "drawtext=fontfile=${font}:text='${text}':fontcolor=white:fontsize=24:shadowcolor=black:shadowx=2:shadowy=2:x=w-tw-10:y=10" -vcodec libwebp -lossless 1 -preset picture -loop 0 -an -vsync 0 '${output}'`;

        await new Promise((resolve, reject) =>
            exec(cmd, (e) => (e ? reject(e) : resolve()))
        );

        const final = fs.readFileSync(output);

        await sock.sendMessage(from, {
            sticker: final,
            packname: "CrisBot Pack",
            author: pushName || "Usuario"
        });

        fs.unlinkSync(input);
        fs.unlinkSync(output);

    } catch (err) {
        console.error(err);
        sock.sendMessage(from, { text: "‚ùå Error creando sticker." });
    }
}
break;



case "pin": {
    try {
        if (!args.length) {
            return await sock.sendMessage(from, {
                text: "üìå Usa:\n*#pin <b√∫squeda> [cantidad]*\nEj: #pin gojo satoru 3"
            }, { quoted: msg });
        }

        let cantidad = parseInt(args[args.length - 1]);
        if (isNaN(cantidad)) cantidad = 4;
        cantidad = Math.min(Math.max(cantidad, 2), 7);

        const queryArgs = isNaN(parseInt(args[args.length - 1])) ? args : args.slice(0, -1);
        const query = queryArgs.join(" ");

        const url = `https://www.bing.com/images/search?q=${encodeURIComponent(query)}&form=HDRSC2&first=1`;

        const { data } = await axios.get(url, {
            headers: { "User-Agent": "Mozilla/5.0" }
        });

        let imgs = [...data.matchAll(/murl&quot;:&quot;(.*?)&quot;/g)]
            .map(v => v[1])
            .filter(u => u.startsWith("http"));
        imgs = [...new Set(imgs)];

        if (!imgs.length) {
            return await sock.sendMessage(from, { text: "‚ùå No encontr√© im√°genes." }, { quoted: msg });
        }

        const seleccion = imgs.slice(0, cantidad);

        for (const img of seleccion) {
            await sock.sendMessage(from, {
                image: { url: img },
                caption: `üìå Pinterest style\nüîé *${query}*`
            }, { quoted: msg });
        }

    } catch (e) {
        console.error("PIN ERROR:", e);
        await sock.sendMessage(from, { text: "‚ùå Error buscando im√°genes.\nUsa #report pin" }, { quoted: msg });
    }
    break;
}


case "setbirth": {
  const users = loadUsers();
  initializeUser(users, sender);

  if (!args[0])
    return sock.sendMessage(from, { text: "‚ùÄ Usa: #setbirth DD/MM/AAAA" });

  users[sender].birth = args[0];
  saveUsers(users);

  sock.sendMessage(from, { text: "üéÇ Cumplea√±os guardado." });
}
break;

case "genero": {
  const users = loadUsers();
  initializeUser(users, sender);

  if (!args[0])
    return sock.sendMessage(from, { text: "‚ö• Usa: #genero masculino/femenino/otro" });

  users[sender].genero = args.join(" ");
  saveUsers(users);

  sock.sendMessage(from, { text: "‚ö• G√©nero guardado." });
}
break;



case "brat": {
    try {
        const text = args.join(" ");
        if (!text)
            return sock.sendMessage(from, { text: "‚úèÔ∏è Escribe un texto para generar el brat." });

        const base = Date.now();
        const png = `/sdcard/brat_${base}.png`;
        const webp = `/sdcard/brat_${base}.webp`;

        const bg = "#FF69B4";

        const len = text.length;
        const size = len < 15 ? 90 : len < 30 ? 70 : len < 60 ? 55 : len < 100 ? 40 : 30;

        const wrapped = text.replace(/(.{1,18})(\s+|$)/g, "$1\n").trim();

        // Esta fuente existe en TODOS los Android y es la que usa WhatsApp
        const font = "/system/fonts/Roboto-Regular.ttf";

        // SIN antialias (ES LO QUE TE ROMP√çA)
        const cmd = `
ffmpeg -f lavfi -i color=c=${bg}:s=600x600 \
-vf "drawtext=text='${wrapped.replace(/'/g, "\\'")}':fontcolor=black:fontsize=${size}:line_spacing=15:fontfile='${font}':x=(w-text_w)/2:y=(h-text_h)/2" \
-frames:v 1 '${png}'
`;
        await new Promise((resolve, reject) => exec(cmd, (e) => (e ? reject(e) : resolve())));

        const cmd2 = `ffmpeg -i '${png}' -vcodec libwebp -lossless 1 -preset picture -loop 0 -an -vsync 0 '${webp}'`;
        await new Promise((resolve, reject) => exec(cmd2, (e) => (e ? reject(e) : resolve())));

        const webpBuffer = fs.readFileSync(webp);

        await sock.sendMessage(from, {
            sticker: webpBuffer,
            packname: "Brat Pack üíñ",
            author: "CrisBot"
        });

        fs.unlinkSync(png);
        fs.unlinkSync(webp);

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, { text: "‚ùå Error generando brat üò≠" });
    }
}
break;



case 'emojimix': {
    const texto = args.join(" ");

    if (!texto)
        return sock.sendMessage(from, { text: "üëâ Usa *#emojimix üòä+üòÇ*" });

    await sock.sendMessage(from, { text: "üîÅ Mezclando emojis..." });

    try {
        let [emoji1, emoji2] = texto.split("+");

        if (!emoji1 || !emoji2)
            return sock.sendMessage(from, { text: "‚ùå Formato incorrecto.\nüëâ Usa: *#emojimix üòä+üòÇ*" });

        const url = `https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`;

        const { data } = await axios.get(url);

        if (!data.results || data.results.length === 0)
            return sock.sendMessage(from, { text: "‚ùå Esa combinaci√≥n no existe üò≠" });

        for (let res of data.results) {
            await sock.sendMessage(from, {
                image: { url: res.url },
                caption: `‚ú® EmojiMix\n${emoji1} + ${emoji2}`
            });
        }

    } catch (err) {
        console.log(err);
        await sock.sendMessage(from, { text: "‚ùå Error generando emojimix üò≠" });
    }
}
break;

case "play":
case "audio":
case "ytaudio":
    try {
        const query = args.join(" ");
        if (!query)
            return sock.sendMessage(from, { text: "‚ùó Escribe el nombre de la canci√≥n o un link." });

        let url = query;
        const isLink = /(youtube\.com|youtu\.be)/i.test(query);
        let video;

        if (!isLink) {
            await sock.sendMessage(from, { text: "`üîé Buscando *${query}*..`." });

            const search = await ytSearch(query);
            if (!search.videos.length)
                return sock.sendMessage(from, { text: "‚ùå No encontr√© resultados." });

            video = search.videos[0];
            url = video.url;
        } else {
            video = {
                title: "Audio de YouTube",
                duration: "Desconocido",
                thumbnail: "https://i.ytimg.com/vi/default.jpg",
                author: { name: "Desconocido" },
                views: "Desconocidas"
            };
        }

        // MINIATURA
        const thumb = await getBuffer(video.thumbnail);

        // VISITAS formateadas
        const views = video.views ? video.views.toLocaleString("en-US") : "N/A";

        // ENVIAR INFO
        await sock.sendMessage(from, {
            image: thumb,
            caption:
`> ‚úê Canal ¬ª *${video.author?.name}*
> ‚¥µ Duracion ¬ª *${video.duration}*
> ‚ú∞ Visitas:  *${views}*
> ‚ùí Titulo ¬ª *${video.title}*

üéß *Preparando el audio...*`
        });

        // DESCARGAR AUDIO
            await sock.sendMessage(from, { text: "Sevidor ¬ª `CrizZapp...`"});

        const output = `/sdcard/${Date.now()}.mp3`;

        exec(`yt-dlp -x --audio-format mp3 --audio-quality 5 -o "${output}" "${url}"`,
        async (err) => {
            if (err) {
                console.log(err);
                return sock.sendMessage(from, { text: "‚ùå Error descargando el audio." });
            }

            const buffer = fs.readFileSync(output);

            // ENVIAR AUDIO
            await sock.sendMessage(from, {
                audio: buffer,
                mimetype: "audio/mpeg",
                ptt: false
            });


            fs.unlinkSync(output);
        });

    } catch (e) {
        console.log("Error #play:", e);
        sock.sendMessage(from, { text: "‚ùå Error procesando el audio." });
    }
break;

case "mafia":
    mafiaCommand({ sock, from, sender, args, m });
break;

    case "prueba":
        await handlePrueba(sock, from, args);
        break;

case "calculadora":
case "calc":
    try {
        let expresion = args.join(" ");
        if (!expresion) {
            await sock.sendMessage(from, { text: "‚ùå Debes ingresar una operaci√≥n. Ej: #calculadora 2 + 2" });
            break;
        }

        // Solo permitir n√∫meros, par√©ntesis, espacios y operadores conocidos
        if (/[^0-9+\-*/().\s√ó√∑%^‚àö^><=¬±]/.test(expresion)) {
            await sock.sendMessage(from, { text: "‚ùå Operaci√≥n inv√°lida. Solo se permiten n√∫meros y operadores." });
            break;
        }

        // Reemplazar s√≠mbolos por operadores JS
        expresion = expresion
            .replace(/√ó/g, "*")
            .replace(/√∑/g, "/")
            .replace(/‚àö/g, "Math.sqrt")
            .replace(/\^/g, "**")
            .replace(/%/g, "/100")
            .replace(/¬±/g, "+-"); // ¬± lo tratamos como +- (o se puede personalizar)

        // Evaluar la expresi√≥n de manera segura
        // NOTA: eval se usa con precauci√≥n porque ya filtramos caracteres
        const resultado = eval(expresion);

        // Manejar comparaciones simples (> < >= <=)
        // Si la expresi√≥n incluye >, <, >=, <=, devolvemos true/false
        await sock.sendMessage(from, { text: `üíª Resultado: ${resultado}` });
    } catch (err) {
        await sock.sendMessage(from, { text: "‚ùå Error al calcular la expresi√≥n." });
        console.error(err);
    }
    break;

case "nekos":
case "neko":
    try {
        const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

        // Opcional: pod√©s filtrar por tag, por ejemplo 'neko', 'waifu', etc.
        const tag = args[0] || "neko"; // si el usuario pone #nekos waifu, usa 'waifu'

        const res = await fetch(`https://api.nekosapi.com/v4/images?tags=${tag}`);
        if (!res.ok) throw new Error("Error al obtener la imagen");

        const data = await res.json();

        if (!data.results || data.results.length === 0)
            throw new Error("No hay im√°genes disponibles");

        const imageUrl = data.results[0].url;

        // Descargar la imagen como buffer
        const buffer = await (await fetch(imageUrl)).arrayBuffer();

        // Enviar imagen al chat
        await sock.sendMessage(from, {
            image: Buffer.from(buffer),
            caption: `‚ú® Imagen de Nekos (${tag})`
        });

    } catch (err) {
        console.log("Error #nekos:", err);
        await sock.sendMessage(from, { text: "‚ùå Error al obtener la imagen." });
    }
break;

case "ppt": // #ppt para jugar
    const opciones = ["piedra", "papel", "tijera"];
    const eleccionBot = opciones[Math.floor(Math.random() * opciones.length)];
    const eleccionUsuario = args[0]?.toLowerCase(); // lo que el usuario escribe despu√©s del comando

    if (!opciones.includes(eleccionUsuario)) {
        await sock.sendMessage(from, { text: `‚ùå Uso: #ppt <piedra|papel|tijera>` });
        break;
    }

    let resultado = "";
    if (eleccionUsuario === eleccionBot) {
        resultado = "ü§ù Empate!";
    } else if (
        (eleccionUsuario === "piedra" && eleccionBot === "tijera") ||
        (eleccionUsuario === "papel" && eleccionBot === "piedra") ||
        (eleccionUsuario === "tijera" && eleccionBot === "papel")
    ) {
        resultado = "üéâ Ganaste!";
    } else {
        resultado = "üíÄ Perdeste!";
    }

    await sock.sendMessage(from, { text: `Tu elecci√≥n: ${eleccionUsuario}\nBot: ${eleccionBot}\n${resultado}` });
    break;



  case 'adoptar': {
    // Ej: #adoptar Firulais https://i.postimg.cc/wTkPCNtt/1764291026183.png
    const [nombre, urlImagen] = args; 
    const mensaje = adoptar(nombre, urlImagen);
    await sock.sendMessage(from, {
      image: { url: mascota.imagen },
      caption: mensaje
    });
    break;
  }

  case 'alimentar': {
    const mensaje = alimentar();
    await sock.sendMessage(from, {
      image: { url: mascota.imagen },
      caption: mensaje
    });
    break;
  }

  case 'jugar': {
    const mensaje = jugar();
    await sock.sendMessage(from, {
      image: { url: mascota.imagen },
      caption: mensaje
    });
    break;
  }

  case 'dormir': {
    const mensaje = dormir();
    await sock.sendMessage(from, {
      image: { url: mascota.imagen },
      caption: mensaje
    });
    break;
  }

case "gift": {


const text =
  msg.message?.conversation ||
  msg.message?.extendedTextMessage?.text ||
  "";

    if (sender !== OWNER_JID) return await sock.sendMessage(from, { text: "‚ùå Solo el OWNER puede usar este comando." });

    // Separar args usando el texto del mensaje
    const args = text.trim().split(" ");
    args.shift(); // eliminar "#gift"

    if (args.length < 2) return await sock.sendMessage(from, { text: "‚ùå Uso: #gift [nombre del personaje] [tiempo]\nEj: #gift Hinata Hyuga 15m" });

    const durationArg = args.pop(); // √∫ltimo argumento = duraci√≥n
    const nombrePersonaje = args.join(" "); // resto = nombre del personaje

    let giftDuration;
    if (durationArg.endsWith("h")) giftDuration = parseInt(durationArg) * 60 * 60 * 1000;
    else if (durationArg.endsWith("m")) giftDuration = parseInt(durationArg) * 60 * 1000;
    else return await sock.sendMessage(from, { text: "‚ùå Tiempo inv√°lido. Usa 15m o 1h." });

    await cmdGift(sock, from, sender, nombrePersonaje, giftDuration);
    break;
}

case "giftoff":
case "apagargift":
    if(sender !== owner) return await sock.sendMessage(from, { text: "‚ùå Solo el OWNER puede usar esto." });
    if(!giftActive) return await sock.sendMessage(from, { text: "‚ö†Ô∏è No hay gift activo." });

    giftActive = false;
    giftedCharacter = null;
    giftEndsAt = null;

    await sock.sendMessage(from, { text: "‚úÖ Gift cancelado exitosamente." });
    break;

case "ownercoins": {

const text =
  msg.message?.conversation ||
  msg.message?.extendedTextMessage?.text ||
  "";

    if (sender !== OWNER_JID)
        return await sock.sendMessage(from, { text: "‚ùå Solo el OWNER puede usar este comando." });

    const args = text.trim().split(" ");
    args.shift();

    const amount = parseInt(args[args.length - 1]);
    if (isNaN(amount) || amount <= 0)
        return await sock.sendMessage(from, { text: "‚ùå Cantidad inv√°lida." });

    const target = m.mentionedJid?.[0] || sender;

    // === LEER USERS.JSON (igual que ranking) ===
    const dataRaw = fs.readFileSync("./settings/users.json", "utf-8");
    const users = JSON.parse(dataRaw);

    // Crear usuario si no existe
    if (!users[target]) {
        users[target] = {
            coins: 0,
            xp: 0,
            vip: false,
            vipExpire: 0
        };
    }

    users[target].coins += amount;

    // === GUARDAR ===
    fs.writeFileSync(
        "./settings/users.json",
        JSON.stringify(users, null, 2)
    );

    await sock.sendMessage(from, {
        text: `ü™ô *Coins otorgadas*\n\nüë§ Usuario: @${target.split("@")[0]}\nüí∞ Cantidad: ${amount}`,
        mentions: [target]
    });

    break;
}

  case 'ver': {
    const data = verMascota();
    await sock.sendMessage(from, {
      image: { url: data.image },
      caption: data.text
    });
    break;
  }

case 'welcome': {
    if (!isGroup)
        return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    const meta = await sock.groupMetadata(from);
    const adminIds = meta.participants.filter(p => p.admin !== null).map(p => p.id);

    if (!adminIds.includes(sender))
        return await sock.sendMessage(from, { text: "‚ùå Solo un admin puede activar el welcome." });

    if (args[0] === "off") {
        welcomeStatus[from] = false;
        saveStatus(); // ‚úÖ guardar estado
        return await sock.sendMessage(from, { text: "üîï *Welcome desactivado.*" });
    }

    welcomeStatus[from] = true;
    saveStatus(); // ‚úÖ guardar estado
    await sock.sendMessage(from, { text: "üîî *Welcome activado.*\nUsa:* #welcome off *para apagarlo.*" });
}
break;



case "ahorcado":
  // Lista de palabras
  const palabras = ["javascript", "programador", "whatsapp", "robot", "computadora"];
  // Elegir palabra al azar
  const palabra = palabras[Math.floor(Math.random() * palabras.length)];
  
  // Crear estado del juego
  let estado = "_".repeat(palabra.length);
  let intentos = 6; // vidas
  let usadas = []; // letras usadas

  // Guardar el juego en memoria (puedes usar un objeto global por chat)
  juegos[from] = { palabra, estado, intentos, usadas };

  await sock.sendMessage(from, { text: `üéØ Ahorcado iniciado!\n${estado}\nTienes ${intentos} intentos.\nUsa #letra <letra>` });
  break;

case "sticker":
case "s": {
    try {

        // Leer si el usuario respondi√≥ un mensaje con imagen o video
        const quoted = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;

        const img = quoted?.imageMessage || info.message?.imageMessage;
        const vid = quoted?.videoMessage || info.message?.videoMessage;

        // Si no hay imagen ni video ‚Üí error
        if (!img && !vid)
            return sock.sendMessage(from, { text: "üìå Responde a una *imagen o video (m√°x 10s)* para hacer sticker." });

        // Si es imagen
        if (img) {
            const buffer = await sock.downloadMediaMessage({ message: { imageMessage: img } });

            await sock.sendMessage(
                from,
                {
                    sticker: buffer,
                    packname: "CrisBot Stickers",
                    author: "Cris"
                },
                { quoted: info }
            );

            return;
        }

        // Si es video de m√°s de 10 s ‚Üí error
        if (vid && vid.seconds > 10)
            return sock.sendMessage(from, { text: "‚ö†Ô∏è El video no puede durar m√°s de 10 segundos." });

        // Si es video v√°lido
        if (vid) {
            const buffer = await sock.downloadMediaMessage({ message: { videoMessage: vid } });

            await sock.sendMessage(
                from,
                {
                    sticker: buffer,
                    packname: "CrisBot Stickers",
                    author: "Cris"
                },
                { quoted: info }
            );

            return;
        }

    } catch (e) {
        console.error(e);
        await sock.sendMessage(from, { text: "‚ùå Error creando sticker." });
    }
}
break;

case "letra":
  const juego = juegos[from];
  if(!juego) return sock.sendMessage(from, { text: "No hay juego en curso. Usa #ahorcado para iniciar." });

  const letra = args[0]?.toLowerCase();
  if(!letra || letra.length !== 1) return sock.sendMessage(from, { text: "Usa una letra v√°lida. Ej: #letra a" });

  if(juego.usadas.includes(letra)) return sock.sendMessage(from, { text: `Ya usaste la letra ${letra}.` });

  juego.usadas.push(letra);

  if(juego.palabra.includes(letra)) {
    // Actualizar estado
    let nuevoEstado = "";
    for(let i = 0; i < juego.palabra.length; i++) {
      nuevoEstado += juego.usadas.includes(juego.palabra[i]) ? juego.palabra[i] : "_";
    }
    juego.estado = nuevoEstado;
    if(!juego.estado.includes("_")) {
      delete juegos[from];
      return sock.sendMessage(from, { text: `üéâ ¬°Ganaste! La palabra era: ${juego.palabra}` });
    }
  } else {
    juego.intentos--;
    if(juego.intentos <= 0) {
      delete juegos[from];
      return sock.sendMessage(from, { text: `üíÄ Perdiste! La palabra era: ${juego.palabra}` });
    }
  }

  await sock.sendMessage(from, { text: `üéØ ${juego.estado}\nIntentos restantes: ${juego.intentos}\nLetras usadas: ${juego.usadas.join(", ")}` });
  break;
 
  case "tts": {
    await cmdTts(
        sock,
        from,
        args.join(" "),
        channelInfo,
        msg
    );
    break;
} 

case "translate": {
  const channelInfo = {
    isForwarded: true,
    forwardingScore: 2,
    forwardedNewsletterMessageInfo: {
      newsletterJid: "120363422781423966@newsletter",
      newsletterName: "‚òºCris Bot - oficial channel‚úß",
      serverMessageId: 1
    }
  };

  // reacci√≥n
  await sock.sendMessage(from, {
    react: { text: "üåç", key: msg.key }
  });

  await cmdTranslate(
    sock,
    from,
    args,
    async (audioData) => {
      await sock.sendMessage(from, {
        audio: audioData,
        mimetype: "audio/mp4",
        ptt: true,
        contextInfo: channelInfo
      });
    }
  );

  break;
}

case "pelea": {
  if (!isGroup)
    return sock.sendMessage(from, {
      text: "‚ùå Este comando solo funciona en grupos."
    });

  const mentioned =
    msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;

  if (!mentioned || mentioned.length === 0)
    return sock.sendMessage(from, {
      text: "‚öîÔ∏è Debes mencionar a alguien\nEjemplo: #pelea @usuario"
    });

  const rival = mentioned[0];
  const user1 = `@${sender.split("@")[0]}`;
  const user2 = `@${rival.split("@")[0]}`;

  const channelInfo = {
    isForwarded: true,
    forwardingScore: 2,
    forwardedNewsletterMessageInfo: {
      newsletterJid: "120363422781423966@newsletter",
      newsletterName: "‚òºCris Bot - oficial channel‚úß",
      serverMessageId: 1
    }
  };

  const peleas = [
    {
      texto: `ü•ä ${user1} le gan√≥ a ${user2} ¬°K.O.! üí•`,
      gif: "https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUybzdoZ2x3aWc2ano5OW93NmMwdmlqczRqMzV2ZjF0aTlsb3V1NnpxZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/xGAv1tD7CBVGLjHj6n/giphy.mp4"
    },
    {
      texto: `ü•ä ${user2} humill√≥ a ${user1} üòµ`,
      gif: "https://media2.giphy.com/media/v1.Y2lkPTZjMDliOTUybmx4MWcyeTlscnBsaWc3emJmNDN1Z215bmY1d21pZnVodDJ2cHpubiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/HfMMHWhM9HwbQsRnVv/giphy.mp4"
    },
    {
      texto: `‚öîÔ∏è ${user1} y ${user2} pelearon fuerte‚Ä¶ ¬°empate! ü§ù`,
      gif: "https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyeHdoMmV5ZnQ5ZzRhY2g4aDI3cTFudWZpaWdtbDEzd3NiYWc1c3RtNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3ofSB2k2KIyfnhi7iE/giphy.mp4"
    }
  ];

  const resultado = peleas[Math.floor(Math.random() * peleas.length)];

  // reacci√≥n
  await sock.sendMessage(from, {
    react: { text: "‚öîÔ∏è", key: msg.key }
  });

  await sock.sendMessage(from, {
    video: { url: resultado.gif },
    caption: resultado.texto,
    gifPlayback: true,
    mentions: [sender, rival],
    contextInfo: channelInfo
  });

  break;
}  

case 'beta': {
    // Mismo flujo que #pelea pero contra el bot
    const user1 = `@${sender.split("@")[0]}`;
    const user2 = '@CrisBot'; // El bot

    const peleas = [
        {
            texto: `ü•ä ${user1} le gan√≥ a ${user2} ¬°K.O.! üí•`,
            gif: 'https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUybzdoZ2x3aWc2ano5OW93NmMwdmlqczRqMzV2ZjF0aTlsb3V1NnpxZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/xGAv1tD7CBVGLjHj6n/giphy.mp4'
        },
        {
            texto: `ü•ä ${user2} humill√≥ a ${user1} üòµ`,
            gif: 'https://media2.giphy.com/media/v1.Y2lkPTZjMDliOTUybmx4MWcyeTlscnBsaWc3emJmNDN1Z215bmY1d21pZnVodDJ2cHpubiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/HfMMHWhM9HwbQsRnVv/giphy.mp4'
        },
        {
            texto: `‚öîÔ∏è ${user1} y ${user2} pelearon fuerte‚Ä¶ ¬°empate! ü§ù`,
            gif: 'https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyeHdoMmV5ZnQ5ZzRhY2g4aDI3cTFudWZpaWdtbDEzd3NiYWc1c3RtNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3ofSB2k2KIyfnhi7iE/giphy.mp4'
        }
    ];
    

    const resultado = peleas[Math.floor(Math.random() * peleas.length)];

    await sock.sendMessage(from, {
        video: { url: resultado.gif },
        caption: resultado.texto,
        gifPlayback: true,
        mentions: [sender] // solo menciona al usuario, no al bot
    });

    break;
}

case 'apk': {

  // ‚è≥ Mensaje previo
  await sock.sendMessage(from, {
    text: 'üì¶ Cargando APK‚Ä¶ ‚åõÔ∏è\nPor favor espera.'
  });

  // üì± Enviar APK
  await sock.sendMessage(from, {
    document: fs.readFileSync('/storage/emulated/0/CrisBot/CrisBot-Base/Que no se caiga! (BETA) .apk'),
    mimetype: 'application/vnd.android.package-archive',
    fileName: 'Que no se caiga! (BETA).apk'
  });

  break;
}

case "baltop":
case "ranking": {
    try {
        const dataRaw = fs.readFileSync("./settings/users.json", "utf-8");
        const users = JSON.parse(dataRaw);

        const sorted = Object.entries(users)
            .filter(([_, info]) => typeof info.coins === "number")
            .sort((a, b) => b[1].coins - a[1].coins)
            .slice(0, 10);

        if (sorted.length === 0) {
            await sock.sendMessage(from, { text: "‚ùå No hay usuarios en el ranking." });
            break;
        }

        let rankingMsg = `üèÜ *TOP 10 ‚Äî RANKING DE COINS* üèÜ\n`;
        rankingMsg += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;

        const mentions = [];

        sorted.forEach(([jid, info], i) => {
            const numero = jid.split("@")[0];
            const name = nombresUsuarios?.[jid] || `@${numero}`;
            const medal =
                i === 0 ? "ü•á" :
                i === 1 ? "ü•à" :
                i === 2 ? "ü•â" : "üîπ";

            mentions.push(jid);

            rankingMsg += `${medal} *${i + 1}.* ${name}\n`;
            rankingMsg += `   üí∞ ${info.coins.toLocaleString()} coins\n\n`;
        });

        rankingMsg += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        rankingMsg += `üî• *¬øPodr√°s llegar al TOP 1?*`;

        await sock.sendMessage(
            from,
            {
                text: rankingMsg,
                mentions,
                contextInfo: channelInfo // si quer√©s que salga con canal
            },
            { quoted: msg }
        );

    } catch (err) {
        console.error("Error leyendo ranking:", err);
        await sock.sendMessage(from, {
            text: "‚ùå Error al obtener el ranking."
        });
    }

    break;
}

case "bio":
case "setbio":
  await cmdSetBio(sock, from, sender, args);
  break;



case 'todos': {
    // Obtener metadata del grupo
    const meta = await sock.groupMetadata(from);
    const participantes = meta.participants;

    // Crear lista de IDs
    const menciones = participantes.map(p => p.id);

    // Generar texto con @tag por cada usuario
    let texto = `üì¢ *REVIVAN TODOS*\n\n`;
    for (let p of participantes) {
        texto += `@${p.id.split("@")[0]}\n`;
    }

    await sock.sendMessage(from, {
        text: texto,
        mentions: menciones
    });

    break;
}

case 'aviso': {
    // Texto que escribi√≥ el usuario
    const aviso = args.join(" ");
    if (!aviso) {
        return await sock.sendMessage(from, { 
            text: "üìå *Debes escribir el aviso*\nEjemplo: #aviso ma√±ana no hay clases",
            quoted: msg 
        });
    }

    // Obtener metadata del grupo
    const meta = await sock.groupMetadata(from);
    const participantes = meta.participants;

    // Crear lista de menciones
    const menciones = participantes.map(p => p.id);

    // Construir mensaje
    let texto = `üì¢ *AVISO IMPORTANTE*\n\n${aviso}\n\nüë• Etiquetados:\n`;
    for (let p of participantes) {
        texto += `@${p.id.split("@")[0]}\n`;
    }

    await sock.sendMessage(from, {
        text: texto,
        mentions: menciones
    });
}
    break;



case 'infobot': {
  const users = JSON.parse(
    fs.readFileSync('./settings/users.json', 'utf-8')
  );

  const imageUrl = "https://i.postimg.cc/85L1jXnF/images-(22).jpg";
  const totalUsers = Object.keys(users).length;

  const ping = Date.now() - m.messageTimestamp * 1000;

  const userData = users[sender];
if (!userData.commandsUsed) userData.commandsUsed = 0;

  let estado = "üü¢ Excelente";
  if (ping > 300) estado = "üü° Chill";
  if (ping > 900) estado = "üî¥ Saturado";

  await sock.sendMessage(from, {
    image: { url: imageUrl },
    caption: `‚õß INFO DEL BOT ‚õß
üë§ @${sender.split("@")[0]}

‚úø *Nombre* ‚ûî ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ

‚ú¶ *Usuarios* ‚ûî ${totalUsers}

‚ùÄ *Tipo* ‚ûî Prem Bot

‚úß *Versi√≥n* ‚ûî *v1.5 - ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ

‚õß *Comandos* ‚ûî 155

‚ùÄ *Comandos usados por @${sender.split("@")[0]}*: ${userData.commandsUsed}

‚ú¶ *Creador* ‚ûî +59898476523

ñ§ê *Canal* ¬ª https://whatsapp.com/channel/0029VbBN8qCG3R3cZASjRO1I

‚ùÄ *Estado* ‚ûî ${estado}`,
    mentions: [sender]
  });

  await sock.sendMessage(from, {
    react: { text: "üíó", key: msg.key }
  });
}
break;

case 'antilink': {
    if (!isGroup) return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    // Solo admins pueden activar
    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants.filter(p => p.admin !== null).map(p => p.id);
    if (!adminIds.includes(sender)) return await sock.sendMessage(from, { text: "‚ùå Solo un admin puede usar este comando." });

    // Obtener argumentos de forma segura
    let args = '';
    if (msg.message?.conversation) {
        args = msg.message.conversation.split(' ')[1];
    } else if (msg.message?.extendedTextMessage?.text) {
        args = msg.message.extendedTextMessage.text.split(' ')[1];
    }

    // Activar o desactivar
    if (args?.toLowerCase() === 'off') {
        antilinkStatus[from] = false;
        saveStatus();
        await sock.sendMessage(from, { text: "‚ùå Sistema antilink desactivado." });
    } else {
        antilinkStatus[from] = true;
        saveStatus();
        await sock.sendMessage(from, { text: "‚úÖ Sistema antilink activado. Cualquier link ser√° expulsado autom√°ticamente." });
    }

    break;
}

case 'kick': {
    // ‚ùå Solo grupos
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Este comando solo funciona en grupos."
        });
    }

    // Obtener admins
    const groupMeta = await sock.groupMetadata(from);
    const participantes = groupMeta.participants;
    const adminIds = participantes
        .filter(p => p.admin !== null)
        .map(p => p.id);

    // ‚ùå No es admin
    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Solo un admin puede usar este comando."
        });
    }

    // ‚ùå No mencion√≥ a nadie
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Debes mencionar a alguien para expulsar."
        });
    }

    try {
        // ‚úÖ Expulsar
        await sock.groupParticipantsUpdate(from, mentioned, "remove");

        // ‚úÖ Reacci√≥n de √©xito
        await sock.sendMessage(from, {
            react: { text: "‚úÖ", key: msg.key }
        });

        await sock.sendMessage(from, {
            text: `‚úÖ ${mentioned.map(u => "@" + u.split("@")[0]).join(", ")} fue expulsado.`,
            mentions: mentioned
        });

    } catch (err) {
        console.error("Error expulsando usuario:", err);

        // üö´ Error
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });

        await sock.sendMessage(from, {
            text: "‚ùå No se pudo expulsar al usuario."
        });
    }

    break;
}

case "marry": {
    const users = loadUsers();
    initializeUser(users, sender);

    // üîπ TOMAR MENCI√ìN IGUAL QUE EN KICK
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const target = mentioned?.[0];

    if (!target) {
        return await sock.sendMessage(from, {
            text: "‚ô° Usa: #marry @persona"
        });
    }

    if (target === sender) {
        return await sock.sendMessage(from, {
            text: "‚ùå No pod√©s casarte contigo mismo."
        });
    }

    initializeUser(users, target);

    // ‚ùå Si alguno ya est√° casado
    if (users[sender].marry) {
        return await sock.sendMessage(from, {
            text: "‚ùå Ya est√°s casado."
        });
    }

    if (users[target].marry) {
        return await sock.sendMessage(from, {
            text: "‚ùå Esa persona ya est√° casada."
        });
    }

    // ‚úÖ ACEPTAR MATRIMONIO
    if (users[sender].marryRequest === target) {
        users[sender].marry = target;
        users[target].marry = sender;

        users[sender].marryRequest = null;
        users[target].marryRequest = null;

        saveUsers(users);

        return await sock.sendMessage(from, {
            text: "üíç ¬°Matrimonio aceptado!",
            mentions: [sender, target]
        });
    }

    // üì© ENVIAR SOLICITUD
users[target].marryRequest = sender;
saveUsers(users);

await sock.sendMessage(from, {
  text: `üíå @${target.split("@")[0]}, @${sender.split("@")[0]} quiete casarse contigoüíç

üëâ Para aceptar escribe:
#marry @${sender.split("@")[0]}`,
  mentions: [sender, target]
});

    break;
}

case "divorce": {
  const users = loadUsers();
  initializeUser(users, sender);

  const pareja = users[sender].marry;
  if (!pareja) {
    return await sock.sendMessage(from, {
      text: "‚ùå No est√°s casado con nadie."
    });
  }

  // Asegurar que la pareja exista en users
  initializeUser(users, pareja);

  // Guardar IDs antes de borrar
  const ex1 = sender;
  const ex2 = pareja;

  // Romper matrimonio
  users[ex1].marry = null;
  users[ex2].marry = null;

  saveUsers(users);

  await sock.sendMessage(from, {
    text: `üíî El matrimonio entre @${ex1.split("@")[0]} y @${ex2.split("@")[0]} ha terminado.`,
    mentions: [ex1, ex2]
  });

  break;
}

case "spam":
    // Verifica si se proporcionaron los argumentos necesarios (cantidad y texto)
    if (args.length < 2) {
        await sock.sendMessage(from, { text: "‚ùå Uso incorrecto. Ejemplo: .spam 5 Hola mundo" });
        break;
    }

    // El primer argumento es la cantidad de mensajes a enviar
    const cantidad = parseInt(args[0]);
    // El resto de los argumentos forman el texto del mensaje
    const textoSpam = args.slice(1).join(" ");

    // Verifica que la cantidad sea un n√∫mero v√°lido y positivo
    if (isNaN(cantidad) || cantidad <= 0) {
        await sock.sendMessage(from, { text: "‚ùå La cantidad debe ser un n√∫mero positivo." });
        break;
    }

    // Bucle para enviar el mensaje repetidamente
    for (let i = 0; i < cantidad; i++) {
        await sock.sendMessage(from, { text: textoSpam });
    }
    break;

case 'pfp': {
    // Obtener el JID de la persona mencionada  
    const mencionado = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];

    if (!mencionado) {
        return sock.sendMessage(from, { 
            text: '‚ùå Debes mencionar a alguien.\nEjemplo: #pfp @usuario',
            contextInfo: channelInfo,
            quoted: msg
        });
    }

    try {
        // Obtener la URL de la foto de perfil
        const url = await sock.profilePictureUrl(mencionado, 'image');

        // Enviar la imagen con menci√≥n, canal y citado
        await sock.sendMessage(from, {   
            image: { url: url },   
            caption: `üì∏ Foto de perfil de @${mencionado.split('@')[0]}`,
            contextInfo: {
                ...channelInfo,             // mantiene la info del canal
                mentionedJid: [mencionado] // agrega la menci√≥n
            },
            quoted: msg
        });
    } catch (err) {
        await sock.sendMessage(from, { 
            text: '‚ùå Esta persona no tiene foto de perfil o no se pudo obtener.',
            contextInfo: channelInfo,
            quoted: msg
        });
    }
    break;
}

case "tienda":
  await cmdTienda(sock, from, sender);
  break;

case "comprar":
  await cmdComprar(sock, from, sender, args);
  break;

case "apoyar":
  await cmdApoyar(sock, from, sender, args);
  break;
  
case "unmute": {
    if (!isGroup)
        return sock.sendMessage(from, { text: "‚ùå Solo en grupos." });

    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    if (!adminIds.includes(sender))
        return sock.sendMessage(from, { text: "‚ùå Solo admins." });

    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0)
        return sock.sendMessage(from, { text: "‚ùå Menciona a alguien." });

    mentioned.forEach(u => mutedUsers.delete(u));

    await sock.sendMessage(from, {
        text: `üîä ${mentioned.map(u => "@" + u.split("@")[0]).join(", ")} fue desmuteado.`,
        mentions: mentioned
    });
    break;
}

        case "contar":
          await sock.sendMessage(from, { text: `Empezando a contar hasta 1000... ¬°aguanta!` });
          for (let i = 1; i <= 1000; i++) {
            await delay(500);
            await sock.sendMessage(from, { text: `${i}` });
          }
          await sock.sendMessage(from, { text: `¬°Termin√© de contar!` });
          break;


case "p":
case "ping": {
  const start = Date.now();

  // Mensaje inicial (este S√ç puede ir quoted)
  const enviado = await sock.sendMessage(
    from,
    {
      text: "`¬°Pong!`\n> ‚¥µ..."
    },
    { quoted: msg }
  );

  // Esperar unos ms para simular c√°lculo
  await new Promise(res => setTimeout(res, 600));

  // Calcular ping
  const ping = Date.now() - start;

  let estado = "Excelente";
  if (ping > 300) estado = "Aceptable";
  if (ping > 900) estado = "Lento";

  // Editar el mensaje inicial
  await sock.sendMessage(from, {
    edit: enviado.key,
    text:
`‚ú∞ *¬°Pong!*
> Tiempo: ‚¥µ *${ping} ms*
> Estado: ‚ú¶ *${estado}*`
  });

  break;
}

case "toigif":
case "#toigif":
case "/toigif": {
  await cmdToIGif(sock, msg, from);
  break;
}

case "toimg":
  await cmdToImg(sock, msg, from);
  break;

case "toivideo":
  await cmdToIVideo(sock, msg, from);
  break;

case "regalornw": {
    const users = loadUsers();
    initializeUser(users, sender);

    // Solo personajes navide√±os üéÑ
    const navidad = personajes.filter(p => p.rareza.includes("Navidad"));
    if (navidad.length === 0) return sock.sendMessage(from, { text: "‚ùå No hay personajes de Navidad disponibles." });

    // Elegir uno aleatorio
    const regalo = navidad[Math.floor(Math.random() * navidad.length)];

    // Enviar mensaje inicial de "abrir regalo"
    let msg = await sock.sendMessage(from, { text: "üéÅ *Abriendo tu regalo navide√±o...*\n[‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 0%" });

    const etapas = [
        "[‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 10%",
        "[‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 20%",
        "[‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 30%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 40%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí] 50%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí] 60%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí] 70%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí] 80%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí] 90%",
        "[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100%"
    ];

    for (let i = 0; i < etapas.length; i++) {
        await sock.sendMessage(from, {
            text: `üéÅ *Abriendo tu regalo navide√±o...*\n${etapas[i]}`,
            edit: msg.key
        });
        await new Promise(res => setTimeout(res, 300));
    }

    // Guardar el personaje en la colecci√≥n autom√°ticamente
    users[sender].rw.push(regalo);
    saveUsers(users);

    // Mensaje final con la imagen
    await sock.sendMessage(from, {
  image: { url: regalo.img },
  caption: `üéÑ ¬°Felicidades ${pushName}! Has recibido a 
*${regalo.nombre}* 
  (${regalo.rareza})
üìñ Ya se agreg√≥ a tu colecci√≥n RW.`,
  contextInfo: channelInfo
});

    break;
}

case "texto": {
  if (!args.length) {
    return sock.sendMessage(from, {
      text: "‚úèÔ∏è Usa el comando as√≠:\n#texto hola mundo",
      contextInfo: channelInfo
    });
  }

  const abecedario = {
    a: "üá¶‚Äå", b: "üáß‚Äå", c: "üá®‚Äå", d: "üá©‚Äå", e: "üá™‚Äå", f: "üá´‚Äå",
    g: "üá¨‚Äå", h: "üá≠‚Äå", i: "üáÆ‚Äå", j: "üáØ‚Äå", k: "üá∞‚Äå", l: "üá±‚Äå",
    m: "üá≤‚Äå", n: "üá≥‚Äå", o: "üá¥‚Äå", p: "üáµ‚Äå", q: "üá∂‚Äå", r: "üá∑‚Äå",
    s: "üá∏‚Äå", t: "üáπ‚Äå", u: "üá∫‚Äå", v: "üáª‚Äå", w: "üáº‚Äå",
    x: "üáΩ‚Äå", y: "üáæ‚Äå", z: "üáø‚Äå"
  };

  const texto = args.join(" ").toLowerCase();
  let resultado = "";

  for (const letra of texto) {
    if (abecedario[letra]) {
      resultado += abecedario[letra];
    } else if (letra === " ") {
      resultado += "   ";
    } else {
      resultado += letra;
    }
  }

  await sock.sendMessage(from, {
    text: resultado,
    contextInfo: {
      ...channelInfo
    }
  });

  break;
}

case "goth":
case "gotico":
case "g√≥tico": {
  if (!args.length) {
    return sock.sendMessage(from, {
      text: "‚úèÔ∏è Usa el comando as√≠:\n#gotico Hola Mundo",
      contextInfo: channelInfo
    });
  }

  const mayusculas = {
    A:"ùï¨", B:"ùï≠", C:"ùïÆ", D:"ùïØ", E:"ùï∞", F:"ùï±",
    G:"ùï≤", H:"ùï≥", I:"ùï¥", J:"ùïµ", K:"ùï∂", L:"ùï∑",
    M:"ùï∏", N:"ùïπ", O:"ùï∫", P:"ùïª", Q:"ùïº", R:"ùïΩ",
    S:"ùïæ", T:"ùïø", U:"ùñÄ", V:"ùñÅ", W:"ùñÇ", X:"ùñÉ",
    Y:"ùñÑ", Z:"ùñÖ"
  };

  const minusculas = {
    a:"ùñÜ", b:"ùñá", c:"ùñà", d:"ùñâ", e:"ùñä", f:"ùñã",
    g:"ùñå", h:"ùñç", i:"ùñé", j:"ùñè", k:"ùñê", l:"ùñë",
    m:"ùñí", n:"ùñì", o:"ùñî", p:"ùñï", q:"ùññ", r:"ùñó",
    s:"ùñò", t:"ùñô", u:"ùñö", v:"ùñõ", w:"ùñú", x:"ùñù",
    y:"ùñû", z:"ùñü"
  };

  const texto = args.join(" ");
  let resultado = "";

  for (const letra of texto) {
    if (mayusculas[letra]) {
      resultado += mayusculas[letra];
    } else if (minusculas[letra]) {
      resultado += minusculas[letra];
    } else {
      resultado += letra; // espacios, n√∫meros, s√≠mbolos
    }
  }

  await sock.sendMessage(from, {
    text: resultado,
    contextInfo: channelInfo
  });

  break;
}

case "memes":
case "meme": {
  await cmdMeme(sock, from, channelInfo);
  break;
}

case 'antiborrar':
case 'antidelete': {
    if (!isGroup) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Este comando solo funciona en grupos."
        });
    }

    const groupMeta = await sock.groupMetadata(from);
    const adminIds = groupMeta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    if (!adminIds.includes(sender)) {
        await sock.sendMessage(from, {
            react: { text: "üö´", key: msg.key }
        });
        return await sock.sendMessage(from, {
            text: "‚ùå Solo un admin puede usar este comando."
        });
    }

    antiDelete[from] = !antiDelete[from];

    await sock.sendMessage(from, {
        react: { text: "‚úÖ", key: msg.key }
    });

    await sock.sendMessage(from, {
        text: `üõ°Ô∏è *Anti-borrar* ${antiDelete[from] ? "activado" : "desactivado"}`
    });

    break;
}


// Ejemplo b√°sico para enviar un video mp4 como reacci√≥n a un comando
// ------------------- REACCIONES ANIME -------------------

    case 'verchar':
    case 'chars':
        await cmdVerChar(sock, from, sender, args);
        break;


case 'kill': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            text: `${user1} acab√≥ con su propia vida üí•`,
            mentions: [sender]
        });
    } else {
        const user2 = `@${mentioned[0].split("@")[0]}`;
        const videoUrl = 'https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyNjVvczhscTRjM3pxbTZlcTFzaG1ycXo2cWlqOWw0OHFkem5nOG0zNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/BTV1vUcOWht2U/giphy.mp4';
        await sock.sendMessage(from, {
            video: { url: videoUrl },
            caption: `${user1} acab√≥ con ${user2} üí•`,
            gifPlayback: true,
            mentions: [sender, mentioned[0]]
        });
    }
    break;
}

case 'hentai': {
    if (!isGroup) {
        await sock.sendMessage(from, { text: "‚ùå Solo funciona en grupos." });
        break;
    }

    if (!global.nsfwGroups?.[from]) {
        await sock.sendMessage(from, {
            text: "üîû NSFW desactivado.\nUn admin debe usar *#nsfw on*"
        });
        break;
    }

    try {
        const res = await fetch("https://nekobot.xyz/api/image?type=hentai");
        const data = await res.json();

        if (!data?.message) throw new Error("No image");

        await sock.sendMessage(
            from,
            {
                image: { url: data.message },
                caption: "üîû Hentai",
                contextInfo: channelInfo
            },
            { quoted: msg }
        );

    } catch (e) {
        console.error(e);
        await sock.sendMessage(from, {
            text: "‚ùå Error NSFW (API ca√≠da)."
        });
    }

    break;
}

case 'slap': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            text: `‚ùå ${user1}, debes mencionar a alguien para usar este comando üëã`,
            mentions: [sender]
        });
    } else {
        const user2 = `@${mentioned[0].split("@")[0]}`;
        const videoUrl = 'https://media3.giphy.com/media/v1.Y2lkPTZjMDliOTUyYTYzbGpjMmNxdnJlcmZid3pmOWtya3FrbHF0dDl0NHNnZHI3NW5vMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/HMGYrlGxQu4phgwcn1/giphy.mp4';
        await sock.sendMessage(from, {
            video: { url: videoUrl },
            caption: `üëã ${user1} le dio un cachetazo a ${user2}`,
            gifPlayback: true,
            mentions: [sender, mentioned[0]]
        });
    }
    break;
}

case 'cry': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    const videoUrl = 'https://media.giphy.com/media/ROF8OQvDmxytW/giphy.mp4';

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            video: { url: videoUrl },
            caption: `üò¢ ${user1} est√° llorando solo en la oscuridad`,
            gifPlayback: true,
            mentions: [sender]
        });
    } else {
        const user2 = `@${mentioned[0].split("@")[0]}`;
        await sock.sendMessage(from, {
            video: { url: videoUrl },
            caption: `üò¢ ${user1} est√° llorando por ${user2}`,
            gifPlayback: true,
            mentions: [sender, mentioned[0]]
        });
    }
    break;
}

case 'apoyo': {
    const user1 = `@${sender.split("@")[0]}`;

    const videoUrl = 'https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUyaXlsMHB3YzlnbGl5cWs4NmtmN3V5d3drM3lxNGNwY2prZmttdjA0ZSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/HX8KSZbOU1udHj7skM/giphy.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `${user1} Tienes todo el apoyo de Komi-san („ÄÉ‚ñΩ„ÄÉ)`,
        gifPlayback: true,
        contextInfo: {
            ...channelInfo,
            mentionedJid: [sender]
        }
    }, { quoted: msg });

    break;
}

case 'animo': {
    const user1 = `@${sender.split("@")[0]}`;

    const videoUrl = 'https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUydDFwcGo5ZzRwajF0cGF6ejZrdnNnenZmODAyNGJwNm9oMDV2MTB6OSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/HX8KSZbOU1udHj7skM/giphy.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `${user1}-*Kun* tienes t-todo mi apoyo`,
        gifPlayback: true,
        contextInfo: {
            ...channelInfo,
            mentionedJid: [sender]
        }
    }, { quoted: msg });

    break;
}

case 'uwu':
case 'senpai': {
    const user1 = `@${sender.split("@")[0]}`;

    const videoUrl = 'https://media4.giphy.com/media/v1.Y2lkPTZjMDliOTUyNHFnZHM4eWU4b2RrNDBhZTllMGE1N3Y4ZTQxbGQxOGgxY2hrdmptMCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/kbRdf2haH2iv2mqgPH/giphy.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `${user1}-*Kun* estas demasiado cerca (‚Ä¢Ôø£‚àáÔø£‚Ä¢)`,
        gifPlayback: true,
        contextInfo: {
            ...channelInfo,
            mentionedJid: [sender]
        }
    }, { quoted: msg });

    break;
}



case 'hug': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    if (!mentioned || mentioned.length === 0) {
        return await sock.sendMessage(from, {
            text: "‚ùå Debes mencionar a alguien para dar un abrazo ü§ó"
        });
    }

    const user1 = `@${sender.split("@")[0]}`;
    const user2 = `@${mentioned[0].split("@")[0]}`;
    const videoUrl = 'https://media.giphy.com/media/l2QDM9Jnim1YVILXa/giphy.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `ü§ó ${user1} le da un abrazo a ${user2}`,
        gifPlayback: true,
        contextInfo: channelInfo,
        mentions: [sender, mentioned[0]]
    });

    break;
}

case 'eventos': {
  await sock.sendMessage(from, { 
    contextInfo: channelInfo, 
    text: `üåÉ*EVENTO A√ëO NUEVO + ANIME*üåπ 
üéÅ Regalos diarios 
‚ùÑÔ∏è Comandos especiales 
üåπBonificaciones en econom√≠a 
üß∏Mensajes De Komi 

Usa: 
üéÅ #regalo
üåÉ #komibot 
üß∏ #senpai 
üß∏ #animo 
¬°Felices fiestas! üåÉ`
  });
  break;
}

case 'santaregalo':
case 'neveded': {
  await economia.cmdSantaRegalo(
    sock,
    from,
    sender,
    pushName,
    async (msg) => await sock.sendMessage(from, { text: msg })
  );
  break;
}

case 'komibot': {
  const mensajes = [
    'Komi dice: Se bueno o te quito las coins ',
    'Te estoy vigilando senpaiüôÇ',
    'Usa #work cuidadito con usar #steal frente ami üòë'
  ];

  const random = mensajes[Math.floor(Math.random() * mensajes.length)];

  await sock.sendMessage(from, {     contextInfo: channelInfo, text: random });
  break;
}



case 'cerezo': {
  const texto = args.join(' ');
  if (!texto) {
    await sock.sendMessage(from, { text: 'üå∏ Usa: #cerezo <texto>' });
    break;
  }

  const cerezo = texto.split('').join(' üå∏ ');

  await sock.sendMessage(from, {
    text: `üå∏üß∏TEXTO DE CEREZOüß∏üå∏ 

${cerezo}

‚ú®Ô∏è`
  });
  break;
}

case 'exit': {

    // Si el que envi√≥ el mensaje no es el owner, no se deja usar
    if (sender !== owner) {
        await sock.sendMessage(from, { 
            text: "‚ùå *Solo el OWNER puede usar este comando.*" 
        }, { quoted: msg });
        break;
    }

    // Confirmaci√≥n en el chat
    await sock.sendMessage(from, {
        text: "üÖÇüÑ∑üÑæüÑ∫üÑæ üÑ∫üÑæüÑºüÑ∏ Se despide"
    });

    // Bot abandona el grupo
    await sock.groupLeave(from);

    break;
}



case 'coinflip': {
  const choice = args[0];
  const amount = args[1];

  await economia.cmdCoinflip(
    sock,
    from,
    sender,
    pushName,
    async (msg) => await sock.sendMessage(from, { text: msg }),
    choice,
    amount
  );
  break;
}

case 'regalo': {
  await economia.cmdRegalo(sock, from, sender, pushName, {
    contextInfo: channelInfo
  }, async (msg) => {
    await sock.sendMessage(from, { text: msg });
  });
  break;
}
case 'hug': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            text: `‚ùå Debes mencionar a alguien para dar un abrazo.`,
        });
        break;
    }

    const user2 = `@${mentioned[0].split("@")[0]}`;
    const videoUrl = 'https://media.giphy.com/media/l2QDM9Jnim1YVILXa/giphy.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `ü§ó ${user1} abraz√≥ a ${user2}`,
        mentions: [sender, mentioned[0]],
        gifPlayback: true
    });
    break;
}

case 'smoke': {
    const user1 = `@${sender.split("@")[0]}`;

    // Lista de GIFs
    const gifs = [
        'https://media2.giphy.com/media/v1.Y2lkPTZjMDliOTUycWJlbTJ5OThtZjgzazZyYnFyYXczNDkzcXZtdndmZmRlNW83NHA3biZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/cZutcPhC4FgTnxRHBb/giphy.mp4',
        'https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUyZWJ1NHEycDE1bnBvYmkzZWg4b2l2OHk5cDNkdDBseW93bmk1bGUzayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/GQnEAQaqwOfOHyZIwx/giphy.mp4',
        'https://media1.giphy.com/media/v1.Y2lkPTZjMDliOTUyODF4bDZxMGpzaGN1OW5jeHV6MGhoMjV2cTBlb3ZzZ2FheDRnbXFtZSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/DnhwDPt62MJesiDNfT/giphy.mp4',
        'https://media4.giphy.com/media/v1.Y2lkPTZjMDliOTUyeG5zOWh6Zmt1emtoaWEzYnM3bGk4eWo4czg2MG5lenFpdHRreXh1ZSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/8hmCdMaXUewzcroADq/giphy.mp4'
    ];

    // Elegir GIF aleatorio
    const gifUrl = gifs[Math.floor(Math.random() * gifs.length)];

    await sock.sendMessage(from, {
        video: { url: gifUrl },
        caption: `üö¨ ${user1} est√° fumando‚Ä¶`,
        mentions: [sender],
        gifPlayback: true
    });

    break;
}



case 'kiss': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            text: `‚ùå Debes mencionar a alguien para besar.`,
        });
        break;
    }

    const user2 = `@${mentioned[0].split("@")[0]}`;
    const videoUrl = 'https://i.gifer.com/8Sbz.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `üòò ${user1} bes√≥ a ${user2}`,
        mentions: [sender, mentioned[0]],
        gifPlayback: true
    });
    break;
}

case 'angry': {
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const user1 = `@${sender.split("@")[0]}`;

    if (!mentioned || mentioned.length === 0) {
        await sock.sendMessage(from, {
            text: `Etiqueta a alguien para usar √©ste comando`,
        });
        break;
    }

    const user2 = `@${mentioned[0].split("@")[0]}`;
    const videoUrl = 'https://i.gifer.com/EEgX.mp4';

    await sock.sendMessage(from, {
        video: { url: videoUrl },
        caption: `üò† ${user1} est√° enojado con ${user2}`,
        mentions: [sender, mentioned[0]],
        gifPlayback: true
    });
    break;
}

case "tonto":
case "pendejo":
case "bsc_pendejo": {

  const channelInfo = {
    isForwarded: true,
    forwardingScore: 2,
    forwardedNewsletterMessageInfo: {
      newsletterJid: "120363422781423966@newsletter",
      newsletterName: "ÍßÅ‡º∫ Shoko Komi ‡ºªÍßÇ ‚óè oficial channel‚úß",
      serverMessageId: 1
    }
  };

  // 1) Obtener datos del grupo
  const meta = await sock.groupMetadata(from);
  const participantes = meta.participants;
  const ids = participantes.map(p => p.id);

  // 2) Elegir usuario random
  const randomUser = ids[Math.floor(Math.random() * ids.length)];

  // 3) Mensaje inicial (AQU√ç va el canal)
  let enviado = await sock.sendMessage(from, {
    text: "10.",
    contextInfo: channelInfo
  });

  // --- Edici√≥n 1 ---
  await new Promise(r => setTimeout(r, 500));
  await sock.sendMessage(from, {
    edit: enviado.key,
    text: "50.."
  });

  // --- Edici√≥n 2 ---
  await new Promise(r => setTimeout(r, 500));
  await sock.sendMessage(from, {
    edit: enviado.key,
    text: "90..."
  });

  // --- Edici√≥n 3 ---
  await new Promise(r => setTimeout(r, 500));
  await sock.sendMessage(from, {
    edit: enviado.key,
    text: "100%..‚≠êÔ∏è."
  });

  // --- FINAL ---
  await new Promise(r => setTimeout(r, 800));
  await sock.sendMessage(from, {
    edit: enviado.key,
    text:
      `*B√∫squeda de mensajes pendejos exitosa*\n\n` +
      `üìå *El elegido pendejo del grupo es:* @${randomUser.split("@")[0]}\n\n` +
      `Deja de ser tan pendejo, plis üíÄ`,
    mentions: [randomUser]
  });

  break;
}

case 'bye': {
    if (!isGroup)
        return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    const meta = await sock.groupMetadata(from);
    const adminIds = meta.participants
        .filter(p => p.admin !== null)
        .map(p => p.id);

    if (!adminIds.includes(sender))
        return await sock.sendMessage(from, { text: "‚ùå Solo un admin puede activar el bye." });

    if (args[0] === "off") {
        byeStatus[from] = false;
        saveStatus();
        return await sock.sendMessage(from, { text: "üîï *Bye desactivado.*" });
    }

    byeStatus[from] = true;
    saveStatus();
    await sock.sendMessage(from, { text: "üîî *Bye activado.*\nUsa: *#bye off* para apagarlo." });
}
break;

case 'sendall': {
    const mensaje = args.join(" ");
    if (!mensaje) {
        await sock.sendMessage(from, { text: "‚ùå Debes escribir el mensaje.\nEj: #sendall Tu mensaje largo aqu√≠" });
        break;
    }

    // Obtener todos los grupos guardados en el store
    const chats = Array.from(store.chats.values())
        .filter(c => c.id.endsWith('@g.us'))  // solo grupos
        .map(c => c.id);

    if (chats.length === 0) {
        await sock.sendMessage(from, { text: "‚ùå No hay grupos donde enviar el mensaje." });
        break;
    }

    // Enviar mensaje a todos los grupos
    for (let grupo of chats) {
        await sock.sendMessage(grupo, { text: mensaje });
        await new Promise(r => setTimeout(r, 300)); // delay peque√±o
    }

    await sock.sendMessage(from, { text: `‚úÖ Mensaje enviado a ${chats.length} grupos.` });
}
break;


case 'dance': {
  const videoUrl = 'https://i.gifer.com/2eSh.mp4';

  await sock.sendMessage(from, {
    video: { url: videoUrl },
    caption: '¬°A bailar! üíÉüï∫',
        gifPlayback: true
  });

  break;
}

// Dentro de tu switch de comandos:
case "rw":
  await cmdRW(sock, from, sender, pushName);
  break;

case "claim":
case "c":
  await cmdClaim(sock, from, sender);
  break;

 case "vender":
  await cmdVender(sock, from, sender, pushName, args.join(" "));
  break;

case "tiendarw":
  await cmdVerTiendarw(sock, from);
  break;

case "resumir":
  const text = args.join(" ");
  if (!text) return sock.sendMessage(from, { text: "‚ùå Uso: #resumir [texto]" });

  const resumen = await resumirTexto(text);
  await sock.sendMessage(from, { text: `üìù Resumen:\n${resumen}` });
  break;

case "comprarrw":
  await cmdComprarrw(sock, from, sender, args[0]);
  break;

case "suerte":
case "boost":
    await cmdBoost(sock, from, sender, args[0]);
    break;

case "coleccion":
case "misrw":
  await cmdColeccion(sock, from, sender, pushName);
  break;

case "ia":
  const prompt = args.join(" ");
  if (!prompt) return sock.sendMessage(from, { text: "‚ùå Uso: #ia [tu pregunta o texto]" });

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini", // puedes cambiar a gpt-4o si quieres
      messages: [
        { role: "system", content: "Eres un asistente inteligente que se llama KomiAi Y responde de forma clara y concisa Y amigable Te creo CrizZapp" },
        { role: "user", content: prompt }
      ],
      max_tokens: 300
    });

    const reply = response.choices[0].message.content;
    await sock.sendMessage(from, { text: `\n${reply}` });

  } catch (err) {
    console.error(err);
    await sock.sendMessage(from, { text: "‚ùå Error al procesar la solicitud de IA." });
  }
  break;

case "tag": {
    if (!isGroup)
        return await sock.sendMessage(from, { text: "‚ùå Este comando solo funciona en grupos." });

    if (!args.length)
        return await sock.sendMessage(from, { text: "Debes escribir algo.\nEj: #tag Hola a todos!" });

    // Obtener participantes del grupo
    const groupMeta = await sock.groupMetadata(from);
    const participants = groupMeta.participants.map(p => p.id); // Todos los IDs

    // Mensaje que se enviar√°
    const msgText = args.join(" ");

    // ‚úÖ Enviar mensaje mencionando a todos (aunque no se vea en el texto)
    await sock.sendMessage(from, {
        text: msgText,
        mentions: participants
    });

    break;
}

case "allcommands": {
    const lista = comandos.map(c => `·Øì‚òÖ *#${c}*`).join("\n");
    await sock.sendMessage(from, { text: `> Lista de todos los comandos:\n${lista}` });
}
break;

case "say": {
  if (!args.length)
    return await sock.sendMessage(
      from,
      { text: "‚ùå Debes escribir algo.\nEj: #say Hola!" },
      { quoted: msg }
    );

  const channelInfo = {
    isForwarded: true,
    forwardingScore: 2,
    forwardedNewsletterMessageInfo: {
      newsletterJid: "120363422781423966@newsletter",
      newsletterName: "- üÖÇüÑ∑üÑæüÑ∫üÑæ üÑ∫üÑæüÑºüÑ∏ ‚óã oficial channel‚úß",
      serverMessageId: 1
    }
  };

  await sock.sendMessage(
    from,
    {
      text: args.join(" "),
      contextInfo: channelInfo
    },
    { quoted: msg }
  );

  break;
}

case "slut":
  await economia.cmdSlut(sock, from, sender, pushName, async (msg) => await sock.sendMessage(from, { text: msg }));
  break;

   case "double":
          await economia.cmdDoubleCoins(sock, from, sender, pushName, async (msg) => {
            await sock.sendMessage(from, { text: msg });
          });
          break;

          default:
  await sock.sendMessage(
    from,
    {
      text: `‚úé El comando *#${command}* no existe\n> Usa *#help* para ver la lista de comandos disponibles.`
    },
    { quoted: msg } // ‚Üê as√≠ s√≠ funciona
  );
      }
    } catch (error) {
      console.error(chalk.red("Error en mensajes:"), error);
    }
  });
}

startBot();